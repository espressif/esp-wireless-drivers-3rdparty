diff --git a/components/wpa_supplicant/esp_supplicant/src/crypto/crypto_mbedtls-bignum.c b/components/wpa_supplicant/esp_supplicant/src/crypto/crypto_mbedtls-bignum.c
index 316412e298bc2823be07d280b5477674ea4dd5c9..a4de750ab713f4c434c8dbaa3dbaf12054431204 100644
--- a/components/wpa_supplicant/esp_supplicant/src/crypto/crypto_mbedtls-bignum.c
+++ b/components/wpa_supplicant/esp_supplicant/src/crypto/crypto_mbedtls-bignum.c
@@ -28,7 +28,7 @@ struct crypto_bignum *crypto_bignum_init(void)
         return NULL;
     }
 
-    mbedtls_mpi_init(bn);
+    esp_mbedtls_mpi_init(bn);
 
     return (struct crypto_bignum *)bn;
 }
@@ -42,7 +42,7 @@ struct crypto_bignum *crypto_bignum_init_set(const u8 *buf, size_t len)
         return NULL;
     }
 
-    MBEDTLS_MPI_CHK(mbedtls_mpi_read_binary(bn, buf, len));
+    MBEDTLS_MPI_CHK(esp_mbedtls_mpi_read_binary(bn, buf, len));
     return (struct crypto_bignum *) bn;
 
 cleanup:
@@ -59,8 +59,8 @@ struct crypto_bignum * crypto_bignum_init_uint(unsigned int val)
         return NULL;
     }
 
-    mbedtls_mpi_init(bn);
-    mbedtls_mpi_lset(bn, val);
+    esp_mbedtls_mpi_init(bn);
+    esp_mbedtls_mpi_lset(bn, val);
 
     return (struct crypto_bignum *)bn;
 }
@@ -68,7 +68,7 @@ struct crypto_bignum * crypto_bignum_init_uint(unsigned int val)
 
 void crypto_bignum_deinit(struct crypto_bignum *n, int clear)
 {
-    mbedtls_mpi_free((mbedtls_mpi *)n);
+    esp_mbedtls_mpi_free((mbedtls_mpi *)n);
     os_free((mbedtls_mpi *)n);
 }
 
@@ -83,7 +83,7 @@ int crypto_bignum_to_bin(const struct crypto_bignum *a,
         return -1;
     }
 
-    num_bytes = mbedtls_mpi_size((mbedtls_mpi *) a);
+    num_bytes = esp_mbedtls_mpi_size((mbedtls_mpi *) a);
 
     if ((size_t) num_bytes > buflen) {
         return -1;
@@ -95,7 +95,7 @@ int crypto_bignum_to_bin(const struct crypto_bignum *a,
     }
 
     os_memset(buf, 0, offset);
-    MBEDTLS_MPI_CHK(mbedtls_mpi_write_binary((mbedtls_mpi *) a, buf + offset, mbedtls_mpi_size((mbedtls_mpi *)a)));
+    MBEDTLS_MPI_CHK(esp_mbedtls_mpi_write_binary((mbedtls_mpi *) a, buf + offset, esp_mbedtls_mpi_size((mbedtls_mpi *)a)));
 
     return num_bytes + offset;
 cleanup:
@@ -107,7 +107,7 @@ int crypto_bignum_add(const struct crypto_bignum *a,
                       const struct crypto_bignum *b,
                       struct crypto_bignum *c)
 {
-    return mbedtls_mpi_add_mpi((mbedtls_mpi *) c, (const mbedtls_mpi *) a, (const mbedtls_mpi *) b) ?
+    return esp_mbedtls_mpi_add_mpi((mbedtls_mpi *) c, (const mbedtls_mpi *) a, (const mbedtls_mpi *) b) ?
            -1 : 0;
 }
 
@@ -116,7 +116,7 @@ int crypto_bignum_mod(const struct crypto_bignum *a,
                       const struct crypto_bignum *b,
                       struct crypto_bignum *c)
 {
-    return mbedtls_mpi_mod_mpi((mbedtls_mpi *) c, (const mbedtls_mpi *) a, (const mbedtls_mpi *) b) ? -1 : 0;
+    return esp_mbedtls_mpi_mod_mpi((mbedtls_mpi *) c, (const mbedtls_mpi *) a, (const mbedtls_mpi *) b) ? -1 : 0;
 }
 
 
@@ -125,7 +125,7 @@ int crypto_bignum_exptmod(const struct crypto_bignum *a,
                           const struct crypto_bignum *c,
                           struct crypto_bignum *d)
 {
-    return  mbedtls_mpi_exp_mod((mbedtls_mpi *) d, (const mbedtls_mpi *) a, (const mbedtls_mpi *) b, (const mbedtls_mpi *) c, NULL) ? -1 : 0;
+    return  esp_mbedtls_mpi_exp_mod((mbedtls_mpi *) d, (const mbedtls_mpi *) a, (const mbedtls_mpi *) b, (const mbedtls_mpi *) c, NULL) ? -1 : 0;
 
 }
 
@@ -134,7 +134,7 @@ int crypto_bignum_inverse(const struct crypto_bignum *a,
                           const struct crypto_bignum *b,
                           struct crypto_bignum *c)
 {
-    return mbedtls_mpi_inv_mod((mbedtls_mpi *) c, (const mbedtls_mpi *) a,
+    return esp_mbedtls_mpi_inv_mod((mbedtls_mpi *) c, (const mbedtls_mpi *) a,
                                (const mbedtls_mpi *) b) ? -1 : 0;
 }
 
@@ -143,7 +143,7 @@ int crypto_bignum_sub(const struct crypto_bignum *a,
                       const struct crypto_bignum *b,
                       struct crypto_bignum *c)
 {
-    return mbedtls_mpi_sub_mpi((mbedtls_mpi *) c, (const mbedtls_mpi *) a, (const mbedtls_mpi *) b) ?
+    return esp_mbedtls_mpi_sub_mpi((mbedtls_mpi *) c, (const mbedtls_mpi *) a, (const mbedtls_mpi *) b) ?
            -1 : 0;
 }
 
@@ -152,7 +152,7 @@ int crypto_bignum_div(const struct crypto_bignum *a,
                       const struct crypto_bignum *b,
                       struct crypto_bignum *c)
 {
-    return mbedtls_mpi_div_mpi((mbedtls_mpi *) c, NULL, (const mbedtls_mpi *) a, (const mbedtls_mpi *) b) ?
+    return esp_mbedtls_mpi_div_mpi((mbedtls_mpi *) c, NULL, (const mbedtls_mpi *) a, (const mbedtls_mpi *) b) ?
            -1 : 0;
 }
 
@@ -165,16 +165,16 @@ int crypto_bignum_mulmod(const struct crypto_bignum *a,
     int res;
 #if ALLOW_EVEN_MOD || !CONFIG_MBEDTLS_HARDWARE_MPI // Must enable ALLOW_EVEN_MOD if c is even
     mbedtls_mpi temp;
-    mbedtls_mpi_init(&temp);
+    esp_mbedtls_mpi_init(&temp);
 
-    res = mbedtls_mpi_mul_mpi(&temp, (const mbedtls_mpi *) a, (const mbedtls_mpi *) b);
+    res = esp_mbedtls_mpi_mul_mpi(&temp, (const mbedtls_mpi *) a, (const mbedtls_mpi *) b);
     if (res) {
         return -1;
     }
 
-    res = mbedtls_mpi_mod_mpi((mbedtls_mpi *) d, &temp, (mbedtls_mpi *) c);
+    res = esp_mbedtls_mpi_mod_mpi((mbedtls_mpi *) d, &temp, (mbedtls_mpi *) c);
 
-    mbedtls_mpi_free(&temp);
+    esp_mbedtls_mpi_free(&temp);
 #else
     // Works with odd modulus only, but it is faster with HW acceleration
     res = esp_mpi_mul_mpi_mod((mbedtls_mpi *) d, (mbedtls_mpi *) a, (mbedtls_mpi *) b, (mbedtls_mpi *) c);
@@ -193,7 +193,7 @@ int crypto_bignum_sqrmod(const struct crypto_bignum *a,
         return -1;
     }
 
-    res = mbedtls_mpi_copy((mbedtls_mpi *) tmp,(const mbedtls_mpi *) a);
+    res = esp_mbedtls_mpi_copy((mbedtls_mpi *) tmp,(const mbedtls_mpi *) a);
     res = crypto_bignum_mulmod(a,tmp,b,c);
 
     crypto_bignum_deinit(tmp, 0);
@@ -205,12 +205,12 @@ int crypto_bignum_rshift(const struct crypto_bignum *a, int n,
                          struct crypto_bignum *r)
 {
     int res;
-    res = mbedtls_mpi_copy((mbedtls_mpi *) r,(const mbedtls_mpi *) a);
+    res = esp_mbedtls_mpi_copy((mbedtls_mpi *) r,(const mbedtls_mpi *) a);
     if (res) {
         return -1;
     }
 
-    res = mbedtls_mpi_shift_r((mbedtls_mpi *)r, n);
+    res = esp_mbedtls_mpi_shift_r((mbedtls_mpi *)r, n);
     return res ? -1 : 0;
 
 }
@@ -219,35 +219,35 @@ int crypto_bignum_rshift(const struct crypto_bignum *a, int n,
 int crypto_bignum_cmp(const struct crypto_bignum *a,
                       const struct crypto_bignum *b)
 {
-    return mbedtls_mpi_cmp_mpi((const mbedtls_mpi *) a, (const mbedtls_mpi *) b);
+    return esp_mbedtls_mpi_cmp_mpi((const mbedtls_mpi *) a, (const mbedtls_mpi *) b);
 }
 
 
 int crypto_bignum_bits(const struct crypto_bignum *a)
 {
-    return mbedtls_mpi_bitlen((const mbedtls_mpi *) a);
+    return esp_mbedtls_mpi_bitlen((const mbedtls_mpi *) a);
 }
 
 
 int crypto_bignum_is_zero(const struct crypto_bignum *a)
 {
-    return (mbedtls_mpi_cmp_int((const mbedtls_mpi *) a, 0) == 0);
+    return (esp_mbedtls_mpi_cmp_int((const mbedtls_mpi *) a, 0) == 0);
 }
 
 
 int crypto_bignum_is_one(const struct crypto_bignum *a)
 {
-    return (mbedtls_mpi_cmp_int((const mbedtls_mpi *) a, 1) == 0);
+    return (esp_mbedtls_mpi_cmp_int((const mbedtls_mpi *) a, 1) == 0);
 }
 
 int crypto_bignum_is_odd(const struct crypto_bignum *a)
 {
-    return (mbedtls_mpi_get_bit((const mbedtls_mpi *) a, 0) == 1);
+    return (esp_mbedtls_mpi_get_bit((const mbedtls_mpi *) a, 0) == 1);
 }
 
 int crypto_bignum_rand(struct crypto_bignum *r, const struct crypto_bignum *m)
 {
-    return ((mbedtls_mpi_random((mbedtls_mpi *) r, 0, (const mbedtls_mpi *) m,
+    return ((esp_mbedtls_mpi_random((mbedtls_mpi *) r, 0, (const mbedtls_mpi *) m,
 								crypto_rng_wrapper, NULL) != 0) ? -1 : 0);
 }
 
@@ -257,30 +257,30 @@ int crypto_bignum_legendre(const struct crypto_bignum *a,
     mbedtls_mpi exp, tmp;
     int res = -2, ret;
 
-    mbedtls_mpi_init(&exp);
-    mbedtls_mpi_init(&tmp);
+    esp_mbedtls_mpi_init(&exp);
+    esp_mbedtls_mpi_init(&tmp);
 
     /* exp = (p-1) / 2 */
-    MBEDTLS_MPI_CHK(mbedtls_mpi_sub_int(&exp, (const mbedtls_mpi *) p, 1));
-    MBEDTLS_MPI_CHK(mbedtls_mpi_shift_r(&exp, 1));
-    MBEDTLS_MPI_CHK(mbedtls_mpi_exp_mod(&tmp, (const mbedtls_mpi *) a, &exp, (const mbedtls_mpi *) p, NULL));
+    MBEDTLS_MPI_CHK(esp_mbedtls_mpi_sub_int(&exp, (const mbedtls_mpi *) p, 1));
+    MBEDTLS_MPI_CHK(esp_mbedtls_mpi_shift_r(&exp, 1));
+    MBEDTLS_MPI_CHK(esp_mbedtls_mpi_exp_mod(&tmp, (const mbedtls_mpi *) a, &exp, (const mbedtls_mpi *) p, NULL));
 
-    if (mbedtls_mpi_cmp_int(&tmp, 1) == 0) {
+    if (esp_mbedtls_mpi_cmp_int(&tmp, 1) == 0) {
         res = 1;
-    } else if (mbedtls_mpi_cmp_int(&tmp, 0) == 0
+    } else if (esp_mbedtls_mpi_cmp_int(&tmp, 0) == 0
             /* The below check is workaround for the case where HW
              * does not behave properly for X ^ A mod M when X is
              * power of M. Instead of returning value 0, value M is
              * returned.*/
-            || mbedtls_mpi_cmp_mpi(&tmp, (const mbedtls_mpi *)p) == 0) {
+            || esp_mbedtls_mpi_cmp_mpi(&tmp, (const mbedtls_mpi *)p) == 0) {
         res = 0;
     } else {
         res = -1;
     }
 
 cleanup:
-    mbedtls_mpi_free(&tmp);
-    mbedtls_mpi_free(&exp);
+    esp_mbedtls_mpi_free(&tmp);
+    esp_mbedtls_mpi_free(&exp);
     return res;
 }
 
@@ -294,7 +294,7 @@ int crypto_bignum_to_string(const struct crypto_bignum *a,
         return -1;
     }
 
-    num_bytes = mbedtls_mpi_size((mbedtls_mpi *) a);
+    num_bytes = esp_mbedtls_mpi_size((mbedtls_mpi *) a);
 
     if (padlen > (size_t) num_bytes) {
         offset = padlen - num_bytes;
@@ -303,8 +303,8 @@ int crypto_bignum_to_string(const struct crypto_bignum *a,
     }
 
     os_memset(buf, 0, offset);
-    mbedtls_mpi_write_string((mbedtls_mpi *) a, 16, (char *)(buf + offset),
-                                mbedtls_mpi_size((mbedtls_mpi *)a), &outlen);
+    esp_mbedtls_mpi_write_string((mbedtls_mpi *) a, 16, (char *)(buf + offset),
+                                esp_mbedtls_mpi_size((mbedtls_mpi *)a), &outlen);
 
     return outlen;
 }
@@ -317,10 +317,10 @@ int crypto_bignum_addmod(const struct crypto_bignum *a,
     struct crypto_bignum *tmp = crypto_bignum_init();
     int ret = -1;
 
-    if (mbedtls_mpi_add_mpi((mbedtls_mpi *) tmp, (const mbedtls_mpi *) b, (const mbedtls_mpi *) c) < 0)
+    if (esp_mbedtls_mpi_add_mpi((mbedtls_mpi *) tmp, (const mbedtls_mpi *) b, (const mbedtls_mpi *) c) < 0)
         goto fail;
 
-    if (mbedtls_mpi_mod_mpi( (mbedtls_mpi *) a, (const mbedtls_mpi *) tmp, (const mbedtls_mpi *) d) < 0)
+    if (esp_mbedtls_mpi_mod_mpi( (mbedtls_mpi *) a, (const mbedtls_mpi *) tmp, (const mbedtls_mpi *) d) < 0)
         goto fail;
 
     ret = 0;
diff --git a/components/wpa_supplicant/esp_supplicant/src/crypto/crypto_mbedtls-ec.c b/components/wpa_supplicant/esp_supplicant/src/crypto/crypto_mbedtls-ec.c
index 956a84662c9be221f49060d82d6a60161db188d4..abf322f6b64cb30511143eacb4364db0b98e8b9f 100644
--- a/components/wpa_supplicant/esp_supplicant/src/crypto/crypto_mbedtls-ec.c
+++ b/components/wpa_supplicant/esp_supplicant/src/crypto/crypto_mbedtls-ec.c
@@ -69,9 +69,9 @@ struct crypto_ec *crypto_ec_init(int group)
 		return NULL;
 	}
 
-	mbedtls_ecp_group_init(&e->group);
+	esp_mbedtls_ecp_group_init(&e->group);
 
-	if (mbedtls_ecp_group_load(&e->group, grp_id)) {
+	if (esp_mbedtls_ecp_group_load(&e->group, grp_id)) {
 		crypto_ec_deinit(e);
 		e = NULL;
 	}
@@ -86,7 +86,7 @@ void crypto_ec_deinit(struct crypto_ec *e)
 		return;
 	}
 
-	mbedtls_ecp_group_free(&e->group);
+	esp_mbedtls_ecp_group_free(&e->group);
 	os_free(e);
 }
 
@@ -104,7 +104,7 @@ struct crypto_ec_point *crypto_ec_point_init(struct crypto_ec *e)
 		return NULL;
 	}
 
-	mbedtls_ecp_point_init(pt);
+	esp_mbedtls_ecp_point_init(pt);
 
 	return (struct crypto_ec_point *) pt;
 }
@@ -112,32 +112,32 @@ struct crypto_ec_point *crypto_ec_point_init(struct crypto_ec *e)
 
 size_t crypto_ec_prime_len(struct crypto_ec *e)
 {
-	return mbedtls_mpi_size(&e->group.P);
+	return esp_mbedtls_mpi_size(&e->group.P);
 }
 
 size_t crypto_ec_order_len(struct crypto_ec *e)
 {
-	return mbedtls_mpi_size(&e->group.N);
+	return esp_mbedtls_mpi_size(&e->group.N);
 }
 
 
 size_t crypto_ec_prime_len_bits(struct crypto_ec *e)
 {
-	return mbedtls_mpi_bitlen(&e->group.P);
+	return esp_mbedtls_mpi_bitlen(&e->group.P);
 }
 struct crypto_ec_group *crypto_ec_get_group_byname(const char *name)
 {
 	struct crypto_ec *e;
-	const mbedtls_ecp_curve_info *curve = mbedtls_ecp_curve_info_from_name(name);
+	const mbedtls_ecp_curve_info *curve = esp_mbedtls_ecp_curve_info_from_name(name);
 
 	e = os_zalloc(sizeof(*e));
 	if (e == NULL) {
 		return NULL;
 	}
 
-	mbedtls_ecp_group_init( &e->group );
+	esp_mbedtls_ecp_group_init( &e->group );
 
-	if (mbedtls_ecp_group_load(&e->group, curve->grp_id)) {
+	if (esp_mbedtls_ecp_group_load(&e->group, curve->grp_id)) {
 		crypto_ec_deinit(e);
 		e = NULL;
 	}
@@ -165,14 +165,14 @@ const struct crypto_bignum * crypto_ec_get_b(struct crypto_ec *e)
 
 void crypto_ec_point_deinit(struct crypto_ec_point *p, int clear)
 {
-	mbedtls_ecp_point_free((mbedtls_ecp_point *) p);
+	esp_mbedtls_ecp_point_free((mbedtls_ecp_point *) p);
 	os_free(p);
 }
 
 int crypto_ec_point_to_bin(struct crypto_ec *e,
 		const struct crypto_ec_point *point, u8 *x, u8 *y)
 {
-	int len = mbedtls_mpi_size(&e->group.P);
+	int len = esp_mbedtls_mpi_size(&e->group.P);
 
 	if (x) {
 		if(crypto_bignum_to_bin((struct crypto_bignum *) & ((mbedtls_ecp_point *) point)->MBEDTLS_PRIVATE(X),
@@ -198,17 +198,17 @@ int crypto_ec_get_affine_coordinates(struct crypto_ec *e, struct crypto_ec_point
 	int ret = -1;
 	mbedtls_ecp_point *point = (mbedtls_ecp_point *)pt;
 
-	if (!mbedtls_ecp_is_zero(point)  && (mbedtls_mpi_cmp_int( &point->MBEDTLS_PRIVATE(Z), 1 ) == 0 )) {
+	if (!esp_mbedtls_ecp_is_zero(point)  && (esp_mbedtls_mpi_cmp_int( &point->MBEDTLS_PRIVATE(Z), 1 ) == 0 )) {
 		// Affine coordinates mean that z should be 1,
 		wpa_printf(MSG_ERROR, "Z coordinate is neither 0 or 1");
 		return -1;
 	}
 
 	if (x) {
-		MBEDTLS_MPI_CHK(mbedtls_mpi_copy((mbedtls_mpi*) x, &((mbedtls_ecp_point* )point)->MBEDTLS_PRIVATE(X)));
+		MBEDTLS_MPI_CHK(esp_mbedtls_mpi_copy((mbedtls_mpi*) x, &((mbedtls_ecp_point* )point)->MBEDTLS_PRIVATE(X)));
 	}
 	if (y) {
-		MBEDTLS_MPI_CHK(mbedtls_mpi_copy((mbedtls_mpi*) y, &((mbedtls_ecp_point* )point)->MBEDTLS_PRIVATE(Y)));
+		MBEDTLS_MPI_CHK(esp_mbedtls_mpi_copy((mbedtls_mpi*) y, &((mbedtls_ecp_point* )point)->MBEDTLS_PRIVATE(Y)));
 	}
 	return 0;
 cleanup:
@@ -225,22 +225,22 @@ struct crypto_ec_point *crypto_ec_point_from_bin(struct crypto_ec *e,
 		return NULL;
 	}
 
-	len = mbedtls_mpi_size(&e->group.P);
+	len = esp_mbedtls_mpi_size(&e->group.P);
 
 	pt = os_zalloc(sizeof(mbedtls_ecp_point));
 	if (!pt) {
 		return NULL;
 	}
-	mbedtls_ecp_point_init(pt);
+	esp_mbedtls_ecp_point_init(pt);
 
-	MBEDTLS_MPI_CHK(mbedtls_mpi_read_binary(&pt->MBEDTLS_PRIVATE(X), val, len));
-	MBEDTLS_MPI_CHK(mbedtls_mpi_read_binary(&pt->MBEDTLS_PRIVATE(Y), val + len, len));
-	MBEDTLS_MPI_CHK(mbedtls_mpi_lset((&pt->MBEDTLS_PRIVATE(Z)), 1));
+	MBEDTLS_MPI_CHK(esp_mbedtls_mpi_read_binary(&pt->MBEDTLS_PRIVATE(X), val, len));
+	MBEDTLS_MPI_CHK(esp_mbedtls_mpi_read_binary(&pt->MBEDTLS_PRIVATE(Y), val + len, len));
+	MBEDTLS_MPI_CHK(esp_mbedtls_mpi_lset((&pt->MBEDTLS_PRIVATE(Z)), 1));
 
 	return (struct crypto_ec_point *) pt;
 
 cleanup:
-	mbedtls_ecp_point_free(pt);
+	esp_mbedtls_ecp_point_free(pt);
 	os_free(pt);
 	return NULL;
 }
@@ -253,13 +253,13 @@ int crypto_ec_point_add(struct crypto_ec *e, const struct crypto_ec_point *a,
 	int ret;
 	mbedtls_mpi one;
 
-	mbedtls_mpi_init(&one);
+	esp_mbedtls_mpi_init(&one);
 
-	MBEDTLS_MPI_CHK(mbedtls_mpi_lset( &one, 1 ));
-	MBEDTLS_MPI_CHK(mbedtls_ecp_muladd(&e->group, (mbedtls_ecp_point *) c, &one, (const mbedtls_ecp_point *)a , &one, (const mbedtls_ecp_point *)b));
+	MBEDTLS_MPI_CHK(esp_mbedtls_mpi_lset( &one, 1 ));
+	MBEDTLS_MPI_CHK(esp_mbedtls_ecp_muladd(&e->group, (mbedtls_ecp_point *) c, &one, (const mbedtls_ecp_point *)a , &one, (const mbedtls_ecp_point *)b));
 
 cleanup:
-	mbedtls_mpi_free(&one);
+	esp_mbedtls_mpi_free(&one);
 	return ret ? -1 : 0;
 }
 
@@ -272,21 +272,21 @@ int crypto_ec_point_mul(struct crypto_ec *e, const struct crypto_ec_point *p,
 	mbedtls_entropy_context entropy;
 	mbedtls_ctr_drbg_context ctr_drbg;
 
-	mbedtls_entropy_init(&entropy);
-	mbedtls_ctr_drbg_init(&ctr_drbg);
+	esp_mbedtls_entropy_init(&entropy);
+	esp_mbedtls_ctr_drbg_init(&ctr_drbg);
 
-	MBEDTLS_MPI_CHK(mbedtls_ctr_drbg_seed(&ctr_drbg, mbedtls_entropy_func, &entropy,
+	MBEDTLS_MPI_CHK(esp_mbedtls_ctr_drbg_seed(&ctr_drbg, esp_mbedtls_entropy_func, &entropy,
 				NULL, 0));
 
-	MBEDTLS_MPI_CHK(mbedtls_ecp_mul(&e->group,
+	MBEDTLS_MPI_CHK(esp_mbedtls_ecp_mul(&e->group,
 				(mbedtls_ecp_point *) res,
 				(const mbedtls_mpi *)b,
 				(const mbedtls_ecp_point *)p,
-				mbedtls_ctr_drbg_random,
+				esp_mbedtls_ctr_drbg_random,
 				&ctr_drbg));
 cleanup:
-	mbedtls_ctr_drbg_free(&ctr_drbg);
-	mbedtls_entropy_free(&entropy);
+	esp_mbedtls_ctr_drbg_free(&ctr_drbg);
+	esp_mbedtls_entropy_free(&entropy);
 	return ret ? -1 : 0;
 }
 
@@ -301,12 +301,12 @@ static int ecp_opp(const mbedtls_ecp_group *grp, mbedtls_ecp_point *R, const mbe
 
 	/* Copy */
 	if (R != P) {
-		MBEDTLS_MPI_CHK(mbedtls_ecp_copy(R, P));
+		MBEDTLS_MPI_CHK(esp_mbedtls_ecp_copy(R, P));
 	}
 
 	/* In-place opposite */
-	if (mbedtls_mpi_cmp_int(&R->MBEDTLS_PRIVATE(Y), 0) != 0) {
-		MBEDTLS_MPI_CHK(mbedtls_mpi_sub_mpi(&R->MBEDTLS_PRIVATE(Y), &grp->P, &R->MBEDTLS_PRIVATE(Y)));
+	if (esp_mbedtls_mpi_cmp_int(&R->MBEDTLS_PRIVATE(Y), 0) != 0) {
+		MBEDTLS_MPI_CHK(esp_mbedtls_mpi_sub_mpi(&R->MBEDTLS_PRIVATE(Y), &grp->P, &R->MBEDTLS_PRIVATE(Y)));
 	}
 
 cleanup:
@@ -324,7 +324,7 @@ int crypto_ec_point_solve_y_coord(struct crypto_ec *e,
 {
 	mbedtls_mpi temp;
 	mbedtls_mpi *y_sqr, *y;
-	mbedtls_mpi_init(&temp);
+	esp_mbedtls_mpi_init(&temp);
 	int ret = 0;
 
 	y = &((mbedtls_ecp_point *)p)->MBEDTLS_PRIVATE(Y);
@@ -344,28 +344,28 @@ int crypto_ec_point_solve_y_coord(struct crypto_ec *e,
 
 	if (y_sqr) {
 
-		MBEDTLS_MPI_CHK(mbedtls_mpi_add_int(&temp, &e->group.P, 1));
-		MBEDTLS_MPI_CHK(mbedtls_mpi_div_int(&temp, NULL, &temp, 4));
-		MBEDTLS_MPI_CHK(mbedtls_mpi_exp_mod(y, y_sqr, &temp, &e->group.P, NULL));
+		MBEDTLS_MPI_CHK(esp_mbedtls_mpi_add_int(&temp, &e->group.P, 1));
+		MBEDTLS_MPI_CHK(esp_mbedtls_mpi_div_int(&temp, NULL, &temp, 4));
+		MBEDTLS_MPI_CHK(esp_mbedtls_mpi_exp_mod(y, y_sqr, &temp, &e->group.P, NULL));
 
-		if (y_bit != mbedtls_mpi_get_bit(y, 0))
-			MBEDTLS_MPI_CHK(mbedtls_mpi_sub_mpi(y, &e->group.P, y));
+		if (y_bit != esp_mbedtls_mpi_get_bit(y, 0))
+			MBEDTLS_MPI_CHK(esp_mbedtls_mpi_sub_mpi(y, &e->group.P, y));
 
-		MBEDTLS_MPI_CHK(mbedtls_mpi_copy(&((mbedtls_ecp_point* )p)->MBEDTLS_PRIVATE(X), (const mbedtls_mpi*) x));
-		MBEDTLS_MPI_CHK(mbedtls_mpi_lset(&((mbedtls_ecp_point *)p)->MBEDTLS_PRIVATE(Z), 1));
+		MBEDTLS_MPI_CHK(esp_mbedtls_mpi_copy(&((mbedtls_ecp_point* )p)->MBEDTLS_PRIVATE(X), (const mbedtls_mpi*) x));
+		MBEDTLS_MPI_CHK(esp_mbedtls_mpi_lset(&((mbedtls_ecp_point *)p)->MBEDTLS_PRIVATE(Z), 1));
 	} else {
 		ret = 1;
 	}
 cleanup:
-	mbedtls_mpi_free(&temp);
-	mbedtls_mpi_free(y_sqr);
+	esp_mbedtls_mpi_free(&temp);
+	esp_mbedtls_mpi_free(y_sqr);
 	os_free(y_sqr);
 	return ret ? -1 : 0;
 }
 
 int crypto_get_order(struct crypto_ec_group *group, struct crypto_bignum *x)
 {
-	return mbedtls_mpi_copy((mbedtls_mpi *) x, &((mbedtls_ecp_group *)group)->N);
+	return esp_mbedtls_mpi_copy((mbedtls_mpi *) x, &((mbedtls_ecp_group *)group)->N);
 }
 
 struct crypto_bignum *crypto_ec_point_compute_y_sqr(struct crypto_ec *e,
@@ -379,10 +379,10 @@ struct crypto_bignum *crypto_ec_point_compute_y_sqr(struct crypto_ec *e,
 		return NULL;
 	}
 
-	mbedtls_mpi_init(&temp);
-	mbedtls_mpi_init(&temp2);
-	mbedtls_mpi_init(&num);
-	mbedtls_mpi_init(y_sqr);
+	esp_mbedtls_mpi_init(&temp);
+	esp_mbedtls_mpi_init(&temp2);
+	esp_mbedtls_mpi_init(&num);
+	esp_mbedtls_mpi_init(y_sqr);
 
 	/* y^2 = x^3 + ax + b  mod  P*/
 	/* mbedtls does not have mod-add or mod-mul apis.
@@ -390,28 +390,28 @@ struct crypto_bignum *crypto_ec_point_compute_y_sqr(struct crypto_ec *e,
 	 */
 
 	/* Calculate x^3  mod P*/
-	MBEDTLS_MPI_CHK(mbedtls_mpi_lset(&num, 3));
-	MBEDTLS_MPI_CHK(mbedtls_mpi_exp_mod(&temp, (const mbedtls_mpi *) x, &num, &e->group.P, NULL));
+	MBEDTLS_MPI_CHK(esp_mbedtls_mpi_lset(&num, 3));
+	MBEDTLS_MPI_CHK(esp_mbedtls_mpi_exp_mod(&temp, (const mbedtls_mpi *) x, &num, &e->group.P, NULL));
 
 	/* Calculate ax  mod P*/
-	MBEDTLS_MPI_CHK(mbedtls_mpi_lset(&num, -3));
-	MBEDTLS_MPI_CHK(mbedtls_mpi_mul_mpi(&temp2, (const mbedtls_mpi *) x, &num));
-	MBEDTLS_MPI_CHK(mbedtls_mpi_mod_mpi(&temp2, &temp2, &e->group.P));
+	MBEDTLS_MPI_CHK(esp_mbedtls_mpi_lset(&num, -3));
+	MBEDTLS_MPI_CHK(esp_mbedtls_mpi_mul_mpi(&temp2, (const mbedtls_mpi *) x, &num));
+	MBEDTLS_MPI_CHK(esp_mbedtls_mpi_mod_mpi(&temp2, &temp2, &e->group.P));
 
 	/* Calculate ax + b  mod P. Note that b is already < P*/
-	MBEDTLS_MPI_CHK(mbedtls_mpi_add_mpi(&temp2, &temp2, &e->group.B));
-	MBEDTLS_MPI_CHK(mbedtls_mpi_mod_mpi(&temp2, &temp2, &e->group.P));
+	MBEDTLS_MPI_CHK(esp_mbedtls_mpi_add_mpi(&temp2, &temp2, &e->group.B));
+	MBEDTLS_MPI_CHK(esp_mbedtls_mpi_mod_mpi(&temp2, &temp2, &e->group.P));
 
 	/* Calculate x^3 + ax + b  mod P*/
-	MBEDTLS_MPI_CHK(mbedtls_mpi_add_mpi(&temp2, &temp2, &temp));
-	MBEDTLS_MPI_CHK(mbedtls_mpi_mod_mpi(y_sqr, &temp2, &e->group.P));
+	MBEDTLS_MPI_CHK(esp_mbedtls_mpi_add_mpi(&temp2, &temp2, &temp));
+	MBEDTLS_MPI_CHK(esp_mbedtls_mpi_mod_mpi(y_sqr, &temp2, &e->group.P));
 
 cleanup:
-	mbedtls_mpi_free(&temp);
-	mbedtls_mpi_free(&temp2);
-	mbedtls_mpi_free(&num);
+	esp_mbedtls_mpi_free(&temp);
+	esp_mbedtls_mpi_free(&temp2);
+	esp_mbedtls_mpi_free(&num);
 	if (ret) {
-		mbedtls_mpi_free(y_sqr);
+		esp_mbedtls_mpi_free(y_sqr);
 		os_free(y_sqr);
 		return NULL;
 	} else {
@@ -422,7 +422,7 @@ cleanup:
 int crypto_ec_point_is_at_infinity(struct crypto_ec *e,
 		const struct crypto_ec_point *p)
 {
-	return mbedtls_ecp_is_zero((mbedtls_ecp_point *) p);
+	return esp_mbedtls_ecp_is_zero((mbedtls_ecp_point *) p);
 }
 
 int crypto_ec_point_is_on_curve(struct crypto_ec *e,
@@ -431,23 +431,23 @@ int crypto_ec_point_is_on_curve(struct crypto_ec *e,
 	mbedtls_mpi y_sqr_lhs, *y_sqr_rhs = NULL, two;
 	int ret = 0, on_curve = 0;
 
-	mbedtls_mpi_init(&y_sqr_lhs);
-	mbedtls_mpi_init(&two);
+	esp_mbedtls_mpi_init(&y_sqr_lhs);
+	esp_mbedtls_mpi_init(&two);
 
 	/* Calculate y^2  mod P*/
-	MBEDTLS_MPI_CHK(mbedtls_mpi_lset(&two, 2));
-	MBEDTLS_MPI_CHK(mbedtls_mpi_exp_mod(&y_sqr_lhs, &((const mbedtls_ecp_point *)p)->MBEDTLS_PRIVATE(Y) , &two, &e->group.P, NULL));
+	MBEDTLS_MPI_CHK(esp_mbedtls_mpi_lset(&two, 2));
+	MBEDTLS_MPI_CHK(esp_mbedtls_mpi_exp_mod(&y_sqr_lhs, &((const mbedtls_ecp_point *)p)->MBEDTLS_PRIVATE(Y) , &two, &e->group.P, NULL));
 
 	y_sqr_rhs = (mbedtls_mpi *) crypto_ec_point_compute_y_sqr(e, (const struct crypto_bignum *) & ((const mbedtls_ecp_point *)p)->MBEDTLS_PRIVATE(X));
 
-	if (y_sqr_rhs && (mbedtls_mpi_cmp_mpi(y_sqr_rhs, &y_sqr_lhs) == 0)) {
+	if (y_sqr_rhs && (esp_mbedtls_mpi_cmp_mpi(y_sqr_rhs, &y_sqr_lhs) == 0)) {
 		on_curve = 1;
 	}
 
 cleanup:
-	mbedtls_mpi_free(&y_sqr_lhs);
-	mbedtls_mpi_free(&two);
-	mbedtls_mpi_free(y_sqr_rhs);
+	esp_mbedtls_mpi_free(&y_sqr_lhs);
+	esp_mbedtls_mpi_free(&two);
+	esp_mbedtls_mpi_free(y_sqr_rhs);
 	os_free(y_sqr_rhs);
 	return (ret == 0) && (on_curve == 1);
 }
@@ -456,7 +456,7 @@ int crypto_ec_point_cmp(const struct crypto_ec *e,
 		const struct crypto_ec_point *a,
 		const struct crypto_ec_point *b)
 {
-	return mbedtls_ecp_point_cmp((const mbedtls_ecp_point *) a,
+	return esp_mbedtls_ecp_point_cmp((const mbedtls_ecp_point *) a,
 			(const mbedtls_ecp_point *) b);
 }
 
@@ -466,18 +466,18 @@ int crypto_key_compare(struct crypto_key *key1, struct crypto_key *key2)
 	mbedtls_entropy_context entropy;
 	mbedtls_ctr_drbg_context ctr_drbg;
 
-	mbedtls_entropy_init(&entropy);
-	mbedtls_ctr_drbg_init(&ctr_drbg);
+	esp_mbedtls_entropy_init(&entropy);
+	esp_mbedtls_ctr_drbg_init(&ctr_drbg);
 
-	MBEDTLS_MPI_CHK(mbedtls_ctr_drbg_seed(&ctr_drbg, mbedtls_entropy_func, &entropy, NULL, 0));
-	if (mbedtls_pk_check_pair((mbedtls_pk_context *)key1, (mbedtls_pk_context *)key2, mbedtls_ctr_drbg_random, &ctr_drbg) < 0) {
+	MBEDTLS_MPI_CHK(esp_mbedtls_ctr_drbg_seed(&ctr_drbg, esp_mbedtls_entropy_func, &entropy, NULL, 0));
+	if (esp_mbedtls_pk_check_pair((mbedtls_pk_context *)key1, (mbedtls_pk_context *)key2, esp_mbedtls_ctr_drbg_random, &ctr_drbg) < 0) {
 		goto cleanup;
 	}
 
 	ret = 1;
 cleanup:
-	mbedtls_ctr_drbg_free(&ctr_drbg);
-	mbedtls_entropy_free(&entropy);
+	esp_mbedtls_ctr_drbg_free(&ctr_drbg);
+	esp_mbedtls_entropy_free(&entropy);
 	return ret;
 }
 
@@ -503,7 +503,7 @@ static struct crypto_key *crypto_alloc_key(void)
 		wpa_printf(MSG_ERROR, "%s: memory allocation failed\n", __func__);
 		return NULL;
 	}
-	mbedtls_pk_init(key);
+	esp_mbedtls_pk_init(key);
 
 	return (struct crypto_key *)key;
 }
@@ -542,11 +542,11 @@ struct crypto_key * crypto_ec_set_pubkey_point(const struct crypto_ec_group *gro
 		goto fail;
 	}
 	/* Assign values */
-	if( ( ret = mbedtls_pk_setup( key,
-					mbedtls_pk_info_from_type(MBEDTLS_PK_ECKEY) ) ) != 0 )
+	if( ( ret = esp_mbedtls_pk_setup( key,
+					esp_mbedtls_pk_info_from_type(MBEDTLS_PK_ECKEY) ) ) != 0 )
 		goto fail;
-	mbedtls_ecp_copy(&mbedtls_pk_ec(*key)->MBEDTLS_PRIVATE(Q), point);
-	mbedtls_ecp_group_load(&mbedtls_pk_ec(*key)->MBEDTLS_PRIVATE(grp), MBEDTLS_ECP_DP_SECP256R1);
+	esp_mbedtls_ecp_copy(&mbedtls_pk_ec(*key)->MBEDTLS_PRIVATE(Q), point);
+	esp_mbedtls_ecp_group_load(&mbedtls_pk_ec(*key)->MBEDTLS_PRIVATE(grp), MBEDTLS_ECP_DP_SECP256R1);
 
 	pkey = (struct crypto_key *)key;
 	crypto_ec_point_deinit((struct crypto_ec_point *)point, 0);
@@ -555,7 +555,7 @@ fail:
 	if (point)
 		crypto_ec_point_deinit((struct crypto_ec_point *)point, 0);
 	if (key)
-		mbedtls_pk_free(key);
+		esp_mbedtls_pk_free(key);
 	pkey = NULL;
 	return pkey;
 }
@@ -564,7 +564,7 @@ fail:
 void crypto_ec_free_key(struct crypto_key *key)
 {
 	mbedtls_pk_context *pkey = (mbedtls_pk_context *)key;
-	mbedtls_pk_free(pkey);
+	esp_mbedtls_pk_free(pkey);
 	os_free(key);
 }
 
@@ -576,22 +576,22 @@ struct crypto_ec_point *crypto_ec_get_public_key(struct crypto_key *key)
 }
 
 
-int crypto_ec_get_priv_key_der(struct crypto_key *key, unsigned char **key_data, int *key_len)
+int crypto_ec_get_priv_key_der(struct crypto_key *key, unsigned char **key_data, int *esp_key_len)
 {
 	mbedtls_pk_context *pkey = (mbedtls_pk_context *)key;
 	char der_data[ECP_PRV_DER_MAX_BYTES];
 
-	*key_len = mbedtls_pk_write_key_der(pkey, (unsigned char *)der_data, ECP_PRV_DER_MAX_BYTES);
-	if (*key_len <= 0)
+	*esp_key_len = esp_mbedtls_pk_write_key_der(pkey, (unsigned char *)der_data, ECP_PRV_DER_MAX_BYTES);
+	if (*esp_key_len <= 0)
 		return -1;
 
-	*key_data = os_malloc(*key_len);
+	*key_data = os_malloc(*esp_key_len);
 
 	if (!*key_data) {
 		wpa_printf(MSG_ERROR, "memory allocation failed\n");
 		return -1;
 	}
-	os_memcpy(*key_data, der_data, *key_len);
+	os_memcpy(*key_data, der_data, *esp_key_len);
 
 	return 0;
 }
@@ -618,7 +618,7 @@ int crypto_ec_get_publickey_buf(struct crypto_key *key, u8 *key_buf, int len)
 	int pk_len = 0;
 
 	memset(buf, 0, sizeof(buf) );
-	pk_len = mbedtls_pk_write_pubkey( &c, buf, pkey);
+	pk_len = esp_mbedtls_pk_write_pubkey( &c, buf, pkey);
 
 	if (pk_len < 0)
 		return -1;
@@ -634,7 +634,7 @@ int crypto_ec_get_publickey_buf(struct crypto_key *key, u8 *key_buf, int len)
 int crypto_write_pubkey_der(struct crypto_key *key, unsigned char **key_buf)
 {
 	unsigned char output_buf[1600] = {0};
-	int len = mbedtls_pk_write_pubkey_der((mbedtls_pk_context *)key, output_buf, 1600);
+	int len = esp_mbedtls_pk_write_pubkey_der((mbedtls_pk_context *)key, output_buf, 1600);
 	if (len <= 0)
 		return 0;
 
@@ -656,7 +656,7 @@ struct crypto_key *crypto_ec_get_key(const u8 *privkey, size_t privkey_len)
 		wpa_printf(MSG_ERROR, "memory allocation failed\n");
 		return NULL;
 	}
-	ret = mbedtls_pk_parse_key(kctx, privkey, privkey_len, NULL, 0, crypto_rng_wrapper, NULL);
+	ret = esp_mbedtls_pk_parse_key(kctx, privkey, privkey_len, NULL, 0, crypto_rng_wrapper, NULL);
 
 	if (ret < 0) {
 		//crypto_print_error_string(ret);
@@ -666,7 +666,7 @@ struct crypto_key *crypto_ec_get_key(const u8 *privkey, size_t privkey_len)
 	return (struct crypto_key *)kctx;
 
 fail:
-	mbedtls_pk_free(kctx);
+	esp_mbedtls_pk_free(kctx);
 	os_free(kctx);
 	return NULL;
 }
@@ -716,10 +716,10 @@ int crypto_ecdh(struct crypto_key *key_own, struct crypto_key *key_peer,
 	mbedtls_ctr_drbg_context ctr_drbg;
 	int ret = -1;
 
-	mbedtls_entropy_init(&entropy);
-	mbedtls_ctr_drbg_init(&ctr_drbg);
+	esp_mbedtls_entropy_init(&entropy);
+	esp_mbedtls_ctr_drbg_init(&ctr_drbg);
 
-	if (mbedtls_ctr_drbg_seed(&ctr_drbg, mbedtls_entropy_func, &entropy, NULL, 0) < 0) {
+	if (esp_mbedtls_ctr_drbg_seed(&ctr_drbg, esp_mbedtls_entropy_func, &entropy, NULL, 0) < 0) {
 		goto fail;
 	}
 
@@ -731,11 +731,11 @@ int crypto_ecdh(struct crypto_key *key_own, struct crypto_key *key_peer,
 		goto fail;
 	}
 
-	mbedtls_ecdh_init(ctx);
-	/* No need to setup, done through mbedtls_ecdh_get_params */
+	esp_mbedtls_ecdh_init(ctx);
+	/* No need to setup, done through esp_mbedtls_ecdh_get_params */
 
 	/* set params from our key */
-	if (mbedtls_ecdh_get_params(ctx, mbedtls_pk_ec(*own), MBEDTLS_ECDH_OURS) < 0) {
+	if (esp_mbedtls_ecdh_get_params(ctx, mbedtls_pk_ec(*own), MBEDTLS_ECDH_OURS) < 0) {
 		wpa_printf(MSG_ERROR, "failed to set our ecdh params\n");
 		goto fail;
 	}
@@ -744,13 +744,13 @@ int crypto_ecdh(struct crypto_key *key_own, struct crypto_key *key_peer,
 #define DPP_MAX_SHARED_SECRET_LEN 66
 #endif
 	/* set params from peers key */
-	if (mbedtls_ecdh_get_params(ctx, mbedtls_pk_ec(*peer), MBEDTLS_ECDH_THEIRS) < 0) {
+	if (esp_mbedtls_ecdh_get_params(ctx, mbedtls_pk_ec(*peer), MBEDTLS_ECDH_THEIRS) < 0) {
 		wpa_printf(MSG_ERROR, "failed to set peer's ecdh params\n");
 		goto fail;
 	}
 
-	if (mbedtls_ecdh_calc_secret(ctx, secret_len, secret, DPP_MAX_SHARED_SECRET_LEN,
-				     mbedtls_ctr_drbg_random, &ctr_drbg) < 0) {
+	if (esp_mbedtls_ecdh_calc_secret(ctx, secret_len, secret, DPP_MAX_SHARED_SECRET_LEN,
+				     esp_mbedtls_ctr_drbg_random, &ctr_drbg) < 0) {
 		wpa_printf(MSG_ERROR, "failed to calculate secret\n");
 		goto fail;
 	}
@@ -763,10 +763,10 @@ int crypto_ecdh(struct crypto_key *key_own, struct crypto_key *key_peer,
 	ret = 0;
 
 fail:
-	mbedtls_ctr_drbg_free(&ctr_drbg);
-	mbedtls_entropy_free(&entropy);
+	esp_mbedtls_ctr_drbg_free(&ctr_drbg);
+	esp_mbedtls_entropy_free(&entropy);
 	if (ctx) {
-		mbedtls_ecdh_free(ctx);
+		esp_mbedtls_ecdh_free(ctx);
 		os_free(ctx);
 	}
 	return ret;
@@ -784,16 +784,16 @@ int crypto_ecdsa_get_sign(unsigned char *hash,
 		wpa_printf(MSG_ERROR,"failed to allcate memory\n");
 		return -1;
 	}
-	mbedtls_ecdsa_init(ctx);
+	esp_mbedtls_ecdsa_init(ctx);
 
-	if (mbedtls_ecdsa_from_keypair(ctx, mbedtls_pk_ec(*pkey)) < 0) {
+	if (esp_mbedtls_ecdsa_from_keypair(ctx, mbedtls_pk_ec(*pkey)) < 0) {
 		goto fail;
 	}
-	ret = mbedtls_ecdsa_sign(&ctx->MBEDTLS_PRIVATE(grp), (mbedtls_mpi *)r, (mbedtls_mpi *)s,
+	ret = esp_mbedtls_ecdsa_sign(&ctx->MBEDTLS_PRIVATE(grp), (mbedtls_mpi *)r, (mbedtls_mpi *)s,
 			&ctx->MBEDTLS_PRIVATE(d), hash, SHA256_MAC_LEN, crypto_rng_wrapper, NULL);
 
 fail:
-	mbedtls_ecdsa_free(ctx);
+	esp_mbedtls_ecdsa_free(ctx);
 	os_free(ctx);
 
 	return  ret;
@@ -810,18 +810,18 @@ int crypto_edcsa_sign_verify(const unsigned char *hash,
 		wpa_printf(MSG_ERROR, "failed to allcate memory\n");
 		return ret;
 	}
-	mbedtls_ecdsa_init(ctx);
+	esp_mbedtls_ecdsa_init(ctx);
 
-	if (mbedtls_ecdsa_from_keypair(ctx, mbedtls_pk_ec(*pkey)) < 0)
+	if (esp_mbedtls_ecdsa_from_keypair(ctx, mbedtls_pk_ec(*pkey)) < 0)
 		return ret;
 
-	if((ret = mbedtls_ecdsa_verify(&ctx->MBEDTLS_PRIVATE(grp), hash, hlen,
+	if((ret = esp_mbedtls_ecdsa_verify(&ctx->MBEDTLS_PRIVATE(grp), hash, hlen,
 					&ctx->MBEDTLS_PRIVATE(Q), (mbedtls_mpi *)r, (mbedtls_mpi *)s)) != 0){
 		wpa_printf(MSG_ERROR, "ecdsa verification failed\n");
 		return ret;
 	}
 
-	mbedtls_ecdsa_free(ctx);
+	esp_mbedtls_ecdsa_free(ctx);
 	os_free(ctx);
 
 	return ret;
@@ -834,8 +834,8 @@ void crypto_debug_print_ec_key(const char *title, struct crypto_key *key)
 	mbedtls_ecp_keypair *ecp = mbedtls_pk_ec( *pkey );
 	u8 x[32], y[32], d[32];
 	wpa_printf(MSG_ERROR, "curve: %s\n",
-			mbedtls_ecp_curve_info_from_grp_id( ecp->MBEDTLS_PRIVATE(grp).id )->name );
-	int len = mbedtls_mpi_size((mbedtls_mpi *)crypto_ec_get_prime((struct crypto_ec *)crypto_ec_get_group_from_key(key)));
+			esp_mbedtls_ecp_curve_info_from_grp_id( ecp->MBEDTLS_PRIVATE(grp).id )->name );
+	int len = esp_mbedtls_mpi_size((mbedtls_mpi *)crypto_ec_get_prime((struct crypto_ec *)crypto_ec_get_group_from_key(key)));
 
 	wpa_printf(MSG_ERROR, "prime len is %d\n", len);
 	crypto_ec_point_to_bin((struct crypto_ec *)crypto_ec_get_group_from_key(key), crypto_ec_get_public_key(key), x, y);
@@ -851,7 +851,7 @@ struct crypto_key *crypto_ec_parse_subpub_key(const unsigned char *p, size_t len
 {
 	int ret;
 	mbedtls_pk_context *pkey = (mbedtls_pk_context *)crypto_alloc_key();
-	ret = mbedtls_pk_parse_subpubkey((unsigned char **)&p, p + len, pkey);
+	ret = esp_mbedtls_pk_parse_subpubkey((unsigned char **)&p, p + len, pkey);
 
 	if (ret < 0) {
 		os_free(pkey);
@@ -863,7 +863,7 @@ struct crypto_key *crypto_ec_parse_subpub_key(const unsigned char *p, size_t len
 
 int crypto_is_ec_key(struct crypto_key *key)
 {
-	int ret = mbedtls_pk_can_do((mbedtls_pk_context *)key, MBEDTLS_PK_ECKEY);
+	int ret = esp_mbedtls_pk_can_do((mbedtls_pk_context *)key, MBEDTLS_PK_ECKEY);
 	return  ret;
 }
 
@@ -876,16 +876,16 @@ struct crypto_key * crypto_ec_gen_keypair(u16 ike_group)
 		return NULL;
 	}
 
-	if(mbedtls_pk_setup(kctx,
-				mbedtls_pk_info_from_type(MBEDTLS_PK_ECKEY)) != 0 )
+	if(esp_mbedtls_pk_setup(kctx,
+				esp_mbedtls_pk_info_from_type(MBEDTLS_PK_ECKEY)) != 0 )
 		goto fail;
 
-	mbedtls_ecp_gen_key(MBEDTLS_ECP_DP_SECP256R1, mbedtls_pk_ec(*kctx), //get this from argument
+	esp_mbedtls_ecp_gen_key(MBEDTLS_ECP_DP_SECP256R1, mbedtls_pk_ec(*kctx), //get this from argument
 			crypto_rng_wrapper, NULL);
 
 	return (struct crypto_key *)kctx;
 fail:
-	mbedtls_pk_free(kctx);
+	esp_mbedtls_pk_free(kctx);
 	os_free(kctx);
 	return NULL;
 }
@@ -895,7 +895,7 @@ fail:
  *   namedCurve         OBJECT IDENTIFIER
  * }
  */
-static int pk_write_ec_param( unsigned char **p, unsigned char *start,
+static int esp_pk_write_ec_param( unsigned char **p, unsigned char *start,
 		mbedtls_ecp_keypair *ec )
 {
 	int ret;
@@ -906,7 +906,7 @@ static int pk_write_ec_param( unsigned char **p, unsigned char *start,
 	if( ( ret = mbedtls_oid_get_oid_by_ec_grp( ec->MBEDTLS_PRIVATE(grp).id, &oid, &oid_len ) ) != 0 )
 		return( ret );
 
-	MBEDTLS_ASN1_CHK_ADD( len, mbedtls_asn1_write_oid( p, start, oid, oid_len ) );
+	MBEDTLS_ASN1_CHK_ADD( len, esp_mbedtls_asn1_write_oid( p, start, oid, oid_len ) );
 
 	return( (int) len );
 }
@@ -918,7 +918,7 @@ static int pk_write_ec_pubkey_formatted( unsigned char **p, unsigned char *start
 	size_t len = 0;
 	unsigned char buf[MBEDTLS_ECP_MAX_PT_LEN];
 
-	if( ( ret = mbedtls_ecp_point_write_binary( &ec->MBEDTLS_PRIVATE(grp), &ec->MBEDTLS_PRIVATE(Q),
+	if( ( ret = esp_mbedtls_ecp_point_write_binary( &ec->MBEDTLS_PRIVATE(grp), &ec->MBEDTLS_PRIVATE(Q),
 					format,
 					&len, buf, sizeof( buf ) ) ) != 0 )
 	{
@@ -940,7 +940,7 @@ int mbedtls_pk_write_pubkey_formatted( unsigned char **p, unsigned char *start,
 	int ret;
 	size_t len = 0;
 
-	if( mbedtls_pk_get_type( key ) == MBEDTLS_PK_ECKEY )
+	if( esp_mbedtls_pk_get_type( key ) == MBEDTLS_PK_ECKEY )
 		MBEDTLS_ASN1_CHK_ADD( len, pk_write_ec_pubkey_formatted( p, start, mbedtls_pk_ec( *key ), format ) );
 	else
 		return( MBEDTLS_ERR_PK_FEATURE_UNAVAILABLE );
@@ -974,25 +974,25 @@ int crypto_pk_write_formatted_pubkey_der(mbedtls_pk_context *key, unsigned char
 	len += 1;
 
 
-	MBEDTLS_ASN1_CHK_ADD( len, mbedtls_asn1_write_len( &c, buf, len ) );
-	MBEDTLS_ASN1_CHK_ADD( len, mbedtls_asn1_write_tag( &c, buf, MBEDTLS_ASN1_BIT_STRING ) );
+	MBEDTLS_ASN1_CHK_ADD( len, esp_mbedtls_asn1_write_len( &c, buf, len ) );
+	MBEDTLS_ASN1_CHK_ADD( len, esp_mbedtls_asn1_write_tag( &c, buf, MBEDTLS_ASN1_BIT_STRING ) );
 
-	if( ( ret = mbedtls_oid_get_oid_by_pk_alg( mbedtls_pk_get_type( key ),
+	if( ( ret = mbedtls_oid_get_oid_by_pk_alg( esp_mbedtls_pk_get_type( key ),
 					&oid, &oid_len ) ) != 0 )
 	{
 		return( ret );
 	}
 
-	if( mbedtls_pk_get_type( key ) == MBEDTLS_PK_ECKEY )
+	if( esp_mbedtls_pk_get_type( key ) == MBEDTLS_PK_ECKEY )
 	{
-		MBEDTLS_ASN1_CHK_ADD( par_len, pk_write_ec_param( &c, buf, mbedtls_pk_ec( *key ) ) );
+		MBEDTLS_ASN1_CHK_ADD( par_len, esp_pk_write_ec_param( &c, buf, mbedtls_pk_ec( *key ) ) );
 	}
 
-	MBEDTLS_ASN1_CHK_ADD( len, mbedtls_asn1_write_algorithm_identifier( &c, buf, oid, oid_len,
+	MBEDTLS_ASN1_CHK_ADD( len, esp_mbedtls_asn1_write_algorithm_identifier( &c, buf, oid, oid_len,
 				par_len ) );
 
-	MBEDTLS_ASN1_CHK_ADD( len, mbedtls_asn1_write_len( &c, buf, len ) );
-	MBEDTLS_ASN1_CHK_ADD( len, mbedtls_asn1_write_tag( &c, buf, MBEDTLS_ASN1_CONSTRUCTED |
+	MBEDTLS_ASN1_CHK_ADD( len, esp_mbedtls_asn1_write_len( &c, buf, len ) );
+	MBEDTLS_ASN1_CHK_ADD( len, esp_mbedtls_asn1_write_tag( &c, buf, MBEDTLS_ASN1_CONSTRUCTED |
 				MBEDTLS_ASN1_SEQUENCE ) );
 
 	return( (int) len );
@@ -1035,7 +1035,7 @@ void crypto_ecdh_deinit(struct crypto_ecdh *ecdh)
         if (!ctx) {
                 return;
         }
-        mbedtls_ecdh_free(ctx);
+        esp_mbedtls_ecdh_free(ctx);
         os_free(ctx);
         ctx = NULL;
 }
@@ -1051,43 +1051,43 @@ struct crypto_ecdh * crypto_ecdh_init(int group)
 		wpa_printf(MSG_ERROR, "Memory allocation failed for ecdh context");
 		goto fail;
 	}
-	mbedtls_ecdh_init(ctx);
+	esp_mbedtls_ecdh_init(ctx);
 #ifndef CONFIG_MBEDTLS_ECDH_LEGACY_CONTEXT
 	ctx->var = MBEDTLS_ECDH_VARIANT_MBEDTLS_2_0;
 #endif
 
-	if ((mbedtls_ecp_group_load(ACCESS_ECDH(&ctx, grp), crypto_mbedtls_get_grp_id(group))) != 0) {
+	if ((esp_mbedtls_ecp_group_load(ACCESS_ECDH(&ctx, grp), crypto_mbedtls_get_grp_id(group))) != 0) {
                 wpa_printf(MSG_ERROR, "Failed to set up ECDH context with group info");
                 goto fail;
 	}
 
 	/* Initialize CTR_DRBG context */
-	mbedtls_ctr_drbg_init(&ctr_drbg);
-	mbedtls_entropy_init(&entropy);
+	esp_mbedtls_ctr_drbg_init(&ctr_drbg);
+	esp_mbedtls_entropy_init(&entropy);
 
 	/* Seed and setup CTR_DRBG entropy source for future reseeds */
-	if (mbedtls_ctr_drbg_seed(&ctr_drbg, mbedtls_entropy_func, &entropy, NULL, 0) != 0) {
+	if (esp_mbedtls_ctr_drbg_seed(&ctr_drbg, esp_mbedtls_entropy_func, &entropy, NULL, 0) != 0) {
                 wpa_printf(MSG_ERROR, "Seeding entropy source failed");
                 goto fail;
 	}
 
 	/* Generates ECDH keypair on elliptic curve */
-	if (mbedtls_ecdh_gen_public(ACCESS_ECDH(&ctx, grp), ACCESS_ECDH(&ctx, d), ACCESS_ECDH(&ctx, Q), mbedtls_ctr_drbg_random, &ctr_drbg)!=0) {
+	if (esp_mbedtls_ecdh_gen_public(ACCESS_ECDH(&ctx, grp), ACCESS_ECDH(&ctx, d), ACCESS_ECDH(&ctx, Q), esp_mbedtls_ctr_drbg_random, &ctr_drbg)!=0) {
                 wpa_printf(MSG_ERROR, "ECDH keypair on curve failed");
                 goto fail;
 	}
 
-	mbedtls_ctr_drbg_free(&ctr_drbg);
-	mbedtls_entropy_free(&entropy);
+	esp_mbedtls_ctr_drbg_free(&ctr_drbg);
+	esp_mbedtls_entropy_free(&entropy);
 	return (struct crypto_ecdh *)ctx;
 fail:
 	if (ctx) {
-		mbedtls_ecdh_free(ctx);
+		esp_mbedtls_ecdh_free(ctx);
 		os_free(ctx);
 		ctx = NULL;
 	}
-	mbedtls_ctr_drbg_free(&ctr_drbg);
-	mbedtls_entropy_free(&entropy);
+	esp_mbedtls_ctr_drbg_free(&ctr_drbg);
+	esp_mbedtls_entropy_free(&entropy);
 	return NULL;
 }
 
@@ -1105,7 +1105,7 @@ struct wpabuf * crypto_ecdh_get_pubkey(struct crypto_ecdh *ecdh, int y)
         }
 
 	/* Export an MPI into unsigned big endian binary data of fixed size */
-	mbedtls_mpi_write_binary(ACCESS_ECDH(&ctx, Q).X, buf, prime_len);
+	esp_mbedtls_mpi_write_binary(ACCESS_ECDH(&ctx, Q).X, buf, prime_len);
 	public_key = wpabuf_alloc_copy(buf, 32);
 	os_free(buf);
 	return public_key;
@@ -1129,11 +1129,11 @@ struct wpabuf * crypto_ecdh_set_peerkey(struct crypto_ecdh *ecdh, int inc_y,
 	mbedtls_entropy_context entropy;
 
 	/* Initialize CTR_DRBG context */
-	mbedtls_ctr_drbg_init(&ctr_drbg);
-	mbedtls_entropy_init(&entropy);
+	esp_mbedtls_ctr_drbg_init(&ctr_drbg);
+	esp_mbedtls_entropy_init(&entropy);
 
 	/* Seed and setup CTR_DRBG entropy source for future reseeds */
-	if (mbedtls_ctr_drbg_seed(&ctr_drbg, mbedtls_entropy_func, &entropy, NULL, 0) != 0) {
+	if (esp_mbedtls_ctr_drbg_seed(&ctr_drbg, esp_mbedtls_entropy_func, &entropy, NULL, 0) != 0) {
 		wpa_printf(MSG_ERROR, "Seeding entropy source failed");
 		goto cleanup;
 	}
@@ -1177,9 +1177,9 @@ struct wpabuf * crypto_ecdh_set_peerkey(struct crypto_ecdh *ecdh, int inc_y,
 	mbedtls_pk_context *peer = (mbedtls_pk_context*)pkey;
 
 	/* Setup ECDH context from EC key */
-/* Call to mbedtls_ecdh_get_params() will initialize the context when not LEGACY context */
+/* Call to esp_mbedtls_ecdh_get_params() will initialize the context when not LEGACY context */
         if (ctx != NULL && peer != NULL) {
-                mbedtls_ecp_copy( ACCESS_ECDH(&ctx, Qp), &(mbedtls_pk_ec(*peer))->Q );
+                esp_mbedtls_ecp_copy( ACCESS_ECDH(&ctx, Qp), &(mbedtls_pk_ec(*peer))->Q );
 #ifndef CONFIG_MBEDTLS_ECDH_LEGACY_CONTEXT
                 ctx->var = MBEDTLS_ECDH_VARIANT_MBEDTLS_2_0;
 #endif
@@ -1196,7 +1196,7 @@ struct wpabuf * crypto_ecdh_set_peerkey(struct crypto_ecdh *ecdh, int inc_y,
 
 	/* Calculate secret
 	z = F(DH(x,Y)) */
-	secret_key = mbedtls_ecdh_calc_secret(ctx, &olen, secret, len_prime, mbedtls_ctr_drbg_random, &ctr_drbg);
+	secret_key = esp_mbedtls_ecdh_calc_secret(ctx, &olen, secret, len_prime, esp_mbedtls_ctr_drbg_random, &ctr_drbg);
 	if (secret_key != 0) {
 		wpa_printf(MSG_ERROR, "Calculation of secret failed");
 		goto cleanup;
@@ -1211,8 +1211,8 @@ cleanup:
 	crypto_ec_free_key(pkey);
 	crypto_bignum_deinit(bn_x, 1);
 	crypto_ec_point_deinit(ec_pt, 1);
-	mbedtls_ctr_drbg_free(&ctr_drbg);
-	mbedtls_entropy_free(&entropy);
+	esp_mbedtls_ctr_drbg_free(&ctr_drbg);
+	esp_mbedtls_entropy_free(&entropy);
 	return sh_secret;
 }
 
diff --git a/components/wpa_supplicant/esp_supplicant/src/crypto/crypto_mbedtls-rsa.c b/components/wpa_supplicant/esp_supplicant/src/crypto/crypto_mbedtls-rsa.c
index 450f78b8febde931ff9f7301c92ab1fd6dc1d50e..705dd9924ca4747eb0711cbc90f77a2419c5bf28 100644
--- a/components/wpa_supplicant/esp_supplicant/src/crypto/crypto_mbedtls-rsa.c
+++ b/components/wpa_supplicant/esp_supplicant/src/crypto/crypto_mbedtls-rsa.c
@@ -31,7 +31,7 @@ static void crypto_dump_verify_info(u32 flags)
 {
 	char dump_buffer[1024];
 
-	mbedtls_x509_crt_verify_info(dump_buffer, 1024, "  ! ", flags );
+	esp_mbedtls_x509_crt_verify_info(dump_buffer, 1024, "  ! ", flags );
 	wpa_printf(MSG_ERROR, "%s", dump_buffer);
 }
 #else
@@ -59,28 +59,28 @@ int crypto_verify_cert(const u8 *cert_start, int certlen, const u8 *ca_cert_star
 		wpa_printf(MSG_ERROR, "%s: memory allocation failed", __func__);
 		return -1;
 	}
-	mbedtls_x509_crt_init(cert);
-	mbedtls_x509_crt_init(ca_cert);
-	ret = mbedtls_x509_crt_parse(cert, cert_start, certlen);
+	esp_mbedtls_x509_crt_init(cert);
+	esp_mbedtls_x509_crt_init(ca_cert);
+	ret = esp_mbedtls_x509_crt_parse(cert, cert_start, certlen);
 	if (ret < 0) {
 		wpa_printf(MSG_ERROR, "peer cert parsing failed");
 		goto cleanup;
 	}
-	ret = mbedtls_x509_crt_parse(ca_cert, ca_cert_start, ca_certlen);
+	ret = esp_mbedtls_x509_crt_parse(ca_cert, ca_cert_start, ca_certlen);
 	if (ret < 0) {
 		wpa_printf(MSG_ERROR, "CA cert parsing failed");
 		goto cleanup;
 	}
 
-	ret = mbedtls_x509_crt_verify(cert, ca_cert, NULL, NULL, &flags, NULL, NULL );
+	ret = esp_mbedtls_x509_crt_verify(cert, ca_cert, NULL, NULL, &flags, NULL, NULL );
 
 	/* Certification is failed, try to get some more info */
 	if (ret != 0)
 		crypto_dump_verify_info(flags);
 
 cleanup:
-	mbedtls_x509_crt_free(cert);
-	mbedtls_x509_crt_free(ca_cert);
+	esp_mbedtls_x509_crt_free(cert);
+	esp_mbedtls_x509_crt_free(ca_cert);
 
 	os_free(cert);
 	os_free(ca_cert);
@@ -96,8 +96,8 @@ struct crypto_public_key *  crypto_public_key_import(const u8 *key, size_t len)
 	if (!pkey)
 		return NULL;
 
-	mbedtls_pk_init(pkey);
-	ret = mbedtls_pk_parse_public_key(pkey, key, len);
+	esp_mbedtls_pk_init(pkey);
+	ret = esp_mbedtls_pk_parse_public_key(pkey, key, len);
 
 	if (ret < 0) {
 		wpa_printf(MSG_ERROR, "failed to parse public key");
@@ -117,9 +117,9 @@ struct crypto_private_key *  crypto_private_key_import(const u8 *key,
 	if (!pkey)
 		return NULL;
 
-	mbedtls_pk_init(pkey);
+	esp_mbedtls_pk_init(pkey);
 
-	ret = mbedtls_pk_parse_key(pkey, key, len, (const unsigned char *)passwd,
+	ret = esp_mbedtls_pk_parse_key(pkey, key, len, (const unsigned char *)passwd,
 			passwd ? os_strlen(passwd) : 0, crypto_rng_wrapper, NULL);
 
 	if (ret < 0) {
@@ -148,21 +148,21 @@ struct crypto_public_key *crypto_public_key_from_cert(const u8 *buf,
 		wpa_printf(MSG_ERROR, "failed to allocate memory");
 		goto fail;
 	}
-	mbedtls_x509_crt_init(cert);
+	esp_mbedtls_x509_crt_init(cert);
 
-	ret = mbedtls_x509_crt_parse(cert, buf, len);
+	ret = esp_mbedtls_x509_crt_parse(cert, buf, len);
 	if (ret < 0) {
 		wpa_printf(MSG_ERROR, "cert parsing failed");
 		goto fail;
 	}
 
-	mbedtls_pk_init(kctx);
+	esp_mbedtls_pk_init(kctx);
 
-	if(mbedtls_pk_setup(kctx, mbedtls_pk_info_from_type(mbedtls_pk_get_type(&cert->pk))) != 0) {
+	if(esp_mbedtls_pk_setup(kctx, esp_mbedtls_pk_info_from_type(esp_mbedtls_pk_get_type(&cert->pk))) != 0) {
 		wpa_printf(MSG_ERROR, "key setup failed");
 		goto fail;
 	}
-	ret = mbedtls_rsa_copy(mbedtls_pk_rsa(*kctx), mbedtls_pk_rsa(cert->pk));
+	ret = esp_mbedtls_rsa_copy(mbedtls_pk_rsa(*kctx), mbedtls_pk_rsa(cert->pk));
 
 	if (ret < 0) {
 		wpa_printf(MSG_ERROR, "key copy failed");
@@ -170,7 +170,7 @@ struct crypto_public_key *crypto_public_key_from_cert(const u8 *buf,
 	}
 
 cleanup:
-	mbedtls_x509_crt_free(cert);
+	esp_mbedtls_x509_crt_free(cert);
 	os_free(cert);
 	return (struct crypto_public_key *)kctx;
 fail:
@@ -198,30 +198,30 @@ int crypto_public_key_encrypt_pkcs1_v15(struct crypto_public_key *key,
 		return -1;
 	}
 
-	mbedtls_entropy_init( entropy );
-	mbedtls_ctr_drbg_init( ctr_drbg );
+	esp_mbedtls_entropy_init( entropy );
+	esp_mbedtls_ctr_drbg_init( ctr_drbg );
 
-	ret = mbedtls_ctr_drbg_seed( ctr_drbg, mbedtls_entropy_func,
+	ret = esp_mbedtls_ctr_drbg_seed( ctr_drbg, esp_mbedtls_entropy_func,
 			entropy, (const unsigned char *) pers,
 			strlen( pers ) );
 	if( ret != 0 ) {
-		wpa_printf(MSG_ERROR, " failed  ! mbedtls_ctr_drbg_seed returned %d",
+		wpa_printf(MSG_ERROR, " failed  ! esp_mbedtls_ctr_drbg_seed returned %d",
 				ret );
 		goto cleanup;
 	}
 
-	ret = mbedtls_rsa_pkcs1_encrypt(mbedtls_pk_rsa(*pkey), mbedtls_ctr_drbg_random,
+	ret = esp_mbedtls_rsa_pkcs1_encrypt(mbedtls_pk_rsa(*pkey), esp_mbedtls_ctr_drbg_random,
 					ctr_drbg, inlen, in, out);
 
 	if(ret != 0) {
-		wpa_printf(MSG_ERROR, " failed  !  mbedtls_rsa_pkcs1_encrypt returned -0x%04x", -ret);
+		wpa_printf(MSG_ERROR, " failed  !  esp_mbedtls_rsa_pkcs1_encrypt returned -0x%04x", -ret);
 		goto cleanup;
 	}
 	*outlen = mbedtls_pk_rsa(*pkey)->MBEDTLS_PRIVATE(len);
 
 cleanup:
-	mbedtls_ctr_drbg_free( ctr_drbg );
-	mbedtls_entropy_free( entropy );
+	esp_mbedtls_ctr_drbg_free( ctr_drbg );
+	esp_mbedtls_entropy_free( entropy );
 	os_free(entropy);
 	os_free(ctr_drbg);
 
@@ -247,9 +247,9 @@ int  crypto_private_key_decrypt_pkcs1_v15(struct crypto_private_key *key,
 			os_free(ctr_drbg);
 		return -1;
 	}
-	mbedtls_ctr_drbg_init( ctr_drbg );
-	mbedtls_entropy_init( entropy );
-	ret = mbedtls_ctr_drbg_seed(ctr_drbg, mbedtls_entropy_func,
+	esp_mbedtls_ctr_drbg_init( ctr_drbg );
+	esp_mbedtls_entropy_init( entropy );
+	ret = esp_mbedtls_ctr_drbg_seed(ctr_drbg, esp_mbedtls_entropy_func,
 			entropy, (const unsigned char *) pers,
 			strlen(pers));
 
@@ -257,14 +257,14 @@ int  crypto_private_key_decrypt_pkcs1_v15(struct crypto_private_key *key,
 		goto cleanup;
 
 	i =  mbedtls_pk_rsa(*pkey)->MBEDTLS_PRIVATE(len);
-	ret = mbedtls_rsa_rsaes_pkcs1_v15_decrypt(mbedtls_pk_rsa(*pkey), mbedtls_ctr_drbg_random,
+	ret = esp_mbedtls_rsa_rsaes_pkcs1_v15_decrypt(mbedtls_pk_rsa(*pkey), esp_mbedtls_ctr_drbg_random,
 			ctr_drbg, &i, in, out, *outlen);
 
 	*outlen = i;
 
 cleanup:
-	mbedtls_ctr_drbg_free( ctr_drbg );
-	mbedtls_entropy_free( entropy );
+	esp_mbedtls_ctr_drbg_free( ctr_drbg );
+	esp_mbedtls_entropy_free( entropy );
 	os_free(entropy);
 	os_free(ctr_drbg);
 
@@ -289,22 +289,22 @@ int crypto_private_key_sign_pkcs1(struct crypto_private_key *key,
 			os_free(ctr_drbg);
 		return -1;
 	}
-	mbedtls_ctr_drbg_init( ctr_drbg );
-	mbedtls_entropy_init( entropy );
-	ret = mbedtls_ctr_drbg_seed(ctr_drbg, mbedtls_entropy_func,
+	esp_mbedtls_ctr_drbg_init( ctr_drbg );
+	esp_mbedtls_entropy_init( entropy );
+	ret = esp_mbedtls_ctr_drbg_seed(ctr_drbg, esp_mbedtls_entropy_func,
 			entropy, (const unsigned char *) pers,
 			strlen(pers));
 
-	if((ret = mbedtls_rsa_pkcs1_sign(mbedtls_pk_rsa(*pkey), mbedtls_ctr_drbg_random, ctr_drbg,
+	if((ret = esp_mbedtls_rsa_pkcs1_sign(mbedtls_pk_rsa(*pkey), esp_mbedtls_ctr_drbg_random, ctr_drbg,
 					(mbedtls_pk_rsa(*pkey))->MBEDTLS_PRIVATE(hash_id),
 					inlen, in, out)) != 0 ) {
-		wpa_printf(MSG_ERROR, " failed  ! mbedtls_rsa_pkcs1_sign returned %d", ret );
+		wpa_printf(MSG_ERROR, " failed  ! esp_mbedtls_rsa_pkcs1_sign returned %d", ret );
 		goto cleanup;
 	}
 	*outlen = mbedtls_pk_rsa(*pkey)->MBEDTLS_PRIVATE(len);
 cleanup:
-	mbedtls_ctr_drbg_free( ctr_drbg );
-	mbedtls_entropy_free( entropy );
+	esp_mbedtls_ctr_drbg_free( ctr_drbg );
+	esp_mbedtls_entropy_free( entropy );
 	os_free(entropy);
 	os_free(ctr_drbg);
 	return ret;
@@ -317,7 +317,7 @@ void  crypto_public_key_free(struct crypto_public_key *key)
 	if (!pkey)
 		return;
 
-	mbedtls_pk_free(pkey);
+	esp_mbedtls_pk_free(pkey);
 	os_free(pkey);
 }
 
@@ -328,7 +328,7 @@ void  crypto_private_key_free(struct crypto_private_key *key)
 	if (!pkey)
 		return;
 
-	mbedtls_pk_free(pkey);
+	esp_mbedtls_pk_free(pkey);
 	os_free(pkey);
 }
 
@@ -344,7 +344,7 @@ int  crypto_public_key_decrypt_pkcs1(struct crypto_public_key *key,
 		return -1;
 	}
 
-	if (mbedtls_rsa_public(mbedtls_pk_rsa(*pkey), crypt, plain) < 0)
+	if (esp_mbedtls_rsa_public(mbedtls_pk_rsa(*pkey), crypt, plain) < 0)
 		return -1;
 
 	/*
diff --git a/components/wpa_supplicant/esp_supplicant/src/crypto/crypto_mbedtls.c b/components/wpa_supplicant/esp_supplicant/src/crypto/crypto_mbedtls.c
index b6ec692adcde98eedbb0d0d77dbeea04671af30d..137f15dfcddf1b2b57c2a8c396f18e10f0825e78 100644
--- a/components/wpa_supplicant/esp_supplicant/src/crypto/crypto_mbedtls.c
+++ b/components/wpa_supplicant/esp_supplicant/src/crypto/crypto_mbedtls.c
@@ -44,37 +44,37 @@ static int digest_vector(mbedtls_md_type_t md_type, size_t num_elem,
 	mbedtls_md_context_t md_ctx;
 	int ret;
 
-	mbedtls_md_init(&md_ctx);
+	esp_mbedtls_md_init(&md_ctx);
 
-	md_info = mbedtls_md_info_from_type(md_type);
+	md_info = esp_mbedtls_md_info_from_type(md_type);
 	if (!md_info) {
-		wpa_printf(MSG_ERROR, "mbedtls_md_info_from_type() failed");
+		wpa_printf(MSG_ERROR, "esp_mbedtls_md_info_from_type() failed");
 		return -1;
 	}
 
-	ret = mbedtls_md_setup(&md_ctx, md_info, 0);
+	ret = esp_mbedtls_md_setup(&md_ctx, md_info, 0);
 	if (ret != 0) {
-		wpa_printf(MSG_ERROR, "mbedtls_md_setup() returned error");
+		wpa_printf(MSG_ERROR, "esp_mbedtls_md_setup() returned error");
 		goto cleanup;
 	}
 
-	ret = mbedtls_md_starts(&md_ctx);
+	ret = esp_mbedtls_md_starts(&md_ctx);
 	if (ret != 0) {
-		wpa_printf(MSG_ERROR, "mbedtls_md_starts returned error");
+		wpa_printf(MSG_ERROR, "esp_mbedtls_md_starts returned error");
 		goto cleanup;
 	}
 
 	for (i = 0; i < num_elem; i++) {
-		ret = mbedtls_md_update(&md_ctx, addr[i], len[i]);
+		ret = esp_mbedtls_md_update(&md_ctx, addr[i], len[i]);
 		if (ret != 0) {
-			wpa_printf(MSG_ERROR, "mbedtls_md_update ret=%d", ret);
+			wpa_printf(MSG_ERROR, "esp_mbedtls_md_update ret=%d", ret);
 			goto cleanup;
 		}
 	}
 
-	ret = mbedtls_md_finish(&md_ctx, mac);
+	ret = esp_mbedtls_md_finish(&md_ctx, mac);
 cleanup:
-	mbedtls_md_free(&md_ctx);
+	esp_mbedtls_md_free(&md_ctx);
 
 	return ret;
 
@@ -116,7 +116,7 @@ int md4_vector(size_t num_elem, const u8 *addr[], const size_t *len, u8 *mac)
 #endif
 
 struct crypto_hash * crypto_hash_init(enum crypto_hash_alg alg, const u8 *key,
-				      size_t key_len)
+				      size_t esp_key_len)
 {
 	mbedtls_md_context_t *ctx = NULL;
 	mbedtls_md_type_t md_type;
@@ -161,18 +161,18 @@ struct crypto_hash * crypto_hash_init(enum crypto_hash_alg alg, const u8 *key,
 		return NULL;
 	}
 
-	mbedtls_md_init(ctx);
-	md_info = mbedtls_md_info_from_type(md_type);
+	esp_mbedtls_md_init(ctx);
+	md_info = esp_mbedtls_md_info_from_type(md_type);
 	if (!md_info) {
 		goto cleanup;
 	}
-	if (mbedtls_md_setup(ctx, md_info, is_hmac) != 0) {
+	if (esp_mbedtls_md_setup(ctx, md_info, is_hmac) != 0) {
 		goto cleanup;
 	}
 	if (is_hmac) {
-		ret = mbedtls_md_hmac_starts(ctx, key, key_len);
+		ret = esp_mbedtls_md_hmac_starts(ctx, key, esp_key_len);
 	} else {
-		ret = mbedtls_md_starts(ctx);
+		ret = esp_mbedtls_md_starts(ctx);
 	}
 	if (ret < 0) {
 		goto cleanup;
@@ -180,7 +180,7 @@ struct crypto_hash * crypto_hash_init(enum crypto_hash_alg alg, const u8 *key,
 
 	return (struct crypto_hash *)ctx;
 cleanup:
-	mbedtls_md_free(ctx);
+	esp_mbedtls_md_free(ctx);
 	os_free(ctx);
 	return NULL;
 }
@@ -194,12 +194,12 @@ void crypto_hash_update(struct crypto_hash *crypto_ctx, const u8 *data, size_t l
 		return;
 	}
 	if (ctx->MBEDTLS_PRIVATE(hmac_ctx)) {
-		ret = mbedtls_md_hmac_update(ctx, data, len);
+		ret = esp_mbedtls_md_hmac_update(ctx, data, len);
 	} else {
-		ret = mbedtls_md_update(ctx, data, len);
+		ret = esp_mbedtls_md_update(ctx, data, len);
 	}
 	if (ret != 0) {
-		wpa_printf(MSG_ERROR, "%s: mbedtls_md_hmac_update failed", __func__);
+		wpa_printf(MSG_ERROR, "%s: esp_mbedtls_md_hmac_update failed", __func__);
 	}
 }
 
@@ -216,7 +216,7 @@ int crypto_hash_finish(struct crypto_hash *crypto_ctx, u8 *mac, size_t *len)
 	if (mac == NULL || len == NULL) {
 		goto err;
 	}
-	md_type = mbedtls_md_get_type(ctx->MBEDTLS_PRIVATE(md_info));
+	md_type = esp_mbedtls_md_get_type(ctx->MBEDTLS_PRIVATE(md_info));
 	switch(md_type) {
 	case MBEDTLS_MD_MD5:
 		if (*len < MD5_MAC_LEN) {
@@ -264,20 +264,20 @@ int crypto_hash_finish(struct crypto_hash *crypto_ctx, u8 *mac, size_t *len)
 		goto err;
 	}
 	if (ctx->MBEDTLS_PRIVATE(hmac_ctx)) {
-		ret = mbedtls_md_hmac_finish(ctx, mac);
+		ret = esp_mbedtls_md_hmac_finish(ctx, mac);
 	} else {
-		ret = mbedtls_md_finish(ctx, mac);
+		ret = esp_mbedtls_md_finish(ctx, mac);
 	}
 
 err:
-	mbedtls_md_free(ctx);
+	esp_mbedtls_md_free(ctx);
 	bin_clear_free(ctx, sizeof(*ctx));
 
 	return ret;
 }
 
 static int hmac_vector(mbedtls_md_type_t md_type,
-		       const u8 *key, size_t key_len,
+		       const u8 *key, size_t esp_key_len,
 		       size_t num_elem, const u8 *addr[],
 		       const size_t *len, u8 *mac)
 {
@@ -286,89 +286,89 @@ static int hmac_vector(mbedtls_md_type_t md_type,
 	mbedtls_md_context_t md_ctx;
 	int ret;
 
-	mbedtls_md_init(&md_ctx);
+	esp_mbedtls_md_init(&md_ctx);
 
-	md_info = mbedtls_md_info_from_type(md_type);
+	md_info = esp_mbedtls_md_info_from_type(md_type);
 	if (!md_info) {
 		return -1;
 	}
 
-	ret = mbedtls_md_setup(&md_ctx, md_info, 1);
+	ret = esp_mbedtls_md_setup(&md_ctx, md_info, 1);
 	if (ret != 0) {
 		return(ret);
 	}
 
-	ret = mbedtls_md_hmac_starts(&md_ctx, key, key_len);
+	ret = esp_mbedtls_md_hmac_starts(&md_ctx, key, esp_key_len);
 	if (ret != 0) {
 		return(ret);
 	}
 
 	for (i = 0; i < num_elem; i++) {
-		ret = mbedtls_md_hmac_update(&md_ctx, addr[i], len[i]);
+		ret = esp_mbedtls_md_hmac_update(&md_ctx, addr[i], len[i]);
 		if (ret != 0) {
 			return(ret);
 		}
 
 	}
 
-	ret = mbedtls_md_hmac_finish(&md_ctx, mac);
+	ret = esp_mbedtls_md_hmac_finish(&md_ctx, mac);
 
-	mbedtls_md_free(&md_ctx);
+	esp_mbedtls_md_free(&md_ctx);
 
 	return ret;
 }
 
-int hmac_sha384_vector(const u8 *key, size_t key_len, size_t num_elem,
+int hmac_sha384_vector(const u8 *key, size_t esp_key_len, size_t num_elem,
 		const u8 *addr[], const size_t *len, u8 *mac)
 {
-	return hmac_vector(MBEDTLS_MD_SHA384, key, key_len, num_elem, addr,
+	return hmac_vector(MBEDTLS_MD_SHA384, key, esp_key_len, num_elem, addr,
 			   len, mac);
 }
 
 
-int hmac_sha384(const u8 *key, size_t key_len, const u8 *data,
+int hmac_sha384(const u8 *key, size_t esp_key_len, const u8 *data,
 		size_t data_len, u8 *mac)
 {
-	return hmac_sha384_vector(key, key_len, 1, &data, &data_len, mac);
+	return hmac_sha384_vector(key, esp_key_len, 1, &data, &data_len, mac);
 }
 
-int hmac_sha256_vector(const u8 *key, size_t key_len, size_t num_elem,
+int hmac_sha256_vector(const u8 *key, size_t esp_key_len, size_t num_elem,
 		       const u8 *addr[], const size_t *len, u8 *mac)
 {
-	return hmac_vector(MBEDTLS_MD_SHA256, key, key_len, num_elem, addr,
+	return hmac_vector(MBEDTLS_MD_SHA256, key, esp_key_len, num_elem, addr,
 			   len, mac);
 }
 
-int hmac_sha256(const u8 *key, size_t key_len, const u8 *data,
+int hmac_sha256(const u8 *key, size_t esp_key_len, const u8 *data,
 		size_t data_len, u8 *mac)
 {
-	return hmac_sha256_vector(key, key_len, 1, &data, &data_len, mac);
+	return hmac_sha256_vector(key, esp_key_len, 1, &data, &data_len, mac);
 }
 
-int hmac_md5_vector(const u8 *key, size_t key_len, size_t num_elem,
+int hmac_md5_vector(const u8 *key, size_t esp_key_len, size_t num_elem,
 		    const u8 *addr[], const size_t *len, u8 *mac)
 {
-	return hmac_vector(MBEDTLS_MD_MD5, key, key_len,
+	return hmac_vector(MBEDTLS_MD_MD5, key, esp_key_len,
 			   num_elem, addr, len, mac);
 }
 
-int hmac_md5(const u8 *key, size_t key_len, const u8 *data, size_t data_len,
+int hmac_md5(const u8 *key, size_t esp_key_len, const u8 *data, size_t data_len,
 	     u8 *mac)
 {
-	return hmac_md5_vector(key, key_len, 1, &data, &data_len, mac);
+	return hmac_md5_vector(key, esp_key_len, 1, &data, &data_len, mac);
 }
 
-int hmac_sha1_vector(const u8 *key, size_t key_len, size_t num_elem,
+int hmac_sha1_vector(const u8 *key, size_t esp_key_len, size_t num_elem,
 		     const u8 *addr[], const size_t *len, u8 *mac)
 {
-	return hmac_vector(MBEDTLS_MD_SHA1, key, key_len, num_elem, addr,
+	return hmac_vector(MBEDTLS_MD_SHA1, key, esp_key_len, num_elem, addr,
 			   len, mac);
 }
 
-int hmac_sha1(const u8 *key, size_t key_len, const u8 *data, size_t data_len,
+int hmac_sha1(const u8 *key, size_t esp_key_len, const u8 *data, size_t data_len,
 	      u8 *mac)
 {
-	return hmac_sha1_vector(key, key_len, 1, &data, &data_len, mac);
+	return hmac_sha1_vector(key, esp_key_len, 1, &data, &data_len, mac);
 }
 
 static void *aes_crypt_init(int mode, const u8 *key, size_t len)
@@ -378,17 +378,17 @@ static void *aes_crypt_init(int mode, const u8 *key, size_t len)
 	if (!aes) {
 		return NULL;
 	}
-	mbedtls_aes_init(aes);
+	esp_mbedtls_aes_init(aes);
 
 	if (mode == MBEDTLS_AES_ENCRYPT) {
-		ret = mbedtls_aes_setkey_enc(aes, key, len * 8);
+		ret = esp_mbedtls_aes_setkey_enc(aes, key, len * 8);
 	} else if (mode == MBEDTLS_AES_DECRYPT){
-		ret = mbedtls_aes_setkey_dec(aes, key, len * 8);
+		ret = esp_mbedtls_aes_setkey_dec(aes, key, len * 8);
 	}
 	if (ret < 0) {
-		mbedtls_aes_free(aes);
+		esp_mbedtls_aes_free(aes);
 		os_free(aes);
-		wpa_printf(MSG_ERROR, "%s: mbedtls_aes_setkey_enc/mbedtls_aes_setkey_dec failed", __func__);
+		wpa_printf(MSG_ERROR, "%s: esp_mbedtls_aes_setkey_enc/esp_mbedtls_aes_setkey_dec failed", __func__);
 		return NULL;
 	}
 
@@ -397,13 +397,13 @@ static void *aes_crypt_init(int mode, const u8 *key, size_t len)
 
 static int aes_crypt(void *ctx, int mode, const u8 *in, u8 *out)
 {
-	return mbedtls_aes_crypt_ecb((mbedtls_aes_context *)ctx,
+	return esp_mbedtls_aes_crypt_ecb((mbedtls_aes_context *)ctx,
 				     mode, in, out);
 }
 
 static void aes_crypt_deinit(void *ctx)
 {
-	mbedtls_aes_free((mbedtls_aes_context *)ctx);
+	esp_mbedtls_aes_free((mbedtls_aes_context *)ctx);
 	os_free(ctx);
 }
 
@@ -443,18 +443,18 @@ int aes_128_cbc_encrypt(const u8 *key, const u8 *iv, u8 *data, size_t data_len)
 	mbedtls_aes_context ctx;
 	u8 cbc[MBEDTLS_AES_BLOCK_SIZE];
 
-	mbedtls_aes_init(&ctx);
+	esp_mbedtls_aes_init(&ctx);
 
-	ret = mbedtls_aes_setkey_enc(&ctx, key, 128);
+	ret = esp_mbedtls_aes_setkey_enc(&ctx, key, 128);
 	if (ret < 0) {
-		mbedtls_aes_free(&ctx);
+		esp_mbedtls_aes_free(&ctx);
 		return ret;
 	}
 
 	os_memcpy(cbc, iv, MBEDTLS_AES_BLOCK_SIZE);
-	ret = mbedtls_aes_crypt_cbc(&ctx, MBEDTLS_AES_ENCRYPT,
+	ret = esp_mbedtls_aes_crypt_cbc(&ctx, MBEDTLS_AES_ENCRYPT,
 				    data_len, cbc, data, data);
-	mbedtls_aes_free(&ctx);
+	esp_mbedtls_aes_free(&ctx);
 
 	return ret;
 }
@@ -465,18 +465,18 @@ int aes_128_cbc_decrypt(const u8 *key, const u8 *iv, u8 *data, size_t data_len)
 	mbedtls_aes_context ctx;
 	u8 cbc[MBEDTLS_AES_BLOCK_SIZE];
 
-	mbedtls_aes_init(&ctx);
+	esp_mbedtls_aes_init(&ctx);
 
-	ret = mbedtls_aes_setkey_dec(&ctx, key, 128);
+	ret = esp_mbedtls_aes_setkey_dec(&ctx, key, 128);
 	if (ret < 0) {
-		mbedtls_aes_free(&ctx);
+		esp_mbedtls_aes_free(&ctx);
 		return ret;
 	}
 
 	os_memcpy(cbc, iv, MBEDTLS_AES_BLOCK_SIZE);
-	ret = mbedtls_aes_crypt_cbc(&ctx, MBEDTLS_AES_DECRYPT,
+	ret = esp_mbedtls_aes_crypt_cbc(&ctx, MBEDTLS_AES_DECRYPT,
 				    data_len, cbc, data, data);
-	mbedtls_aes_free(&ctx);
+	esp_mbedtls_aes_free(&ctx);
 
 	return ret;
 
@@ -490,27 +490,27 @@ struct crypto_cipher {
 
 static int crypto_init_cipher_ctx(mbedtls_cipher_context_t *ctx,
 				  const mbedtls_cipher_info_t *cipher_info,
-				  const u8 *iv, const u8 *key, size_t key_len,
+				  const u8 *iv, const u8 *key, size_t esp_key_len,
 				  mbedtls_operation_t operation)
 {
-	mbedtls_cipher_init(ctx);
+	esp_mbedtls_cipher_init(ctx);
 	int ret;
 
-	ret = mbedtls_cipher_setup(ctx, cipher_info);
+	ret = esp_mbedtls_cipher_setup(ctx, cipher_info);
 	if (ret != 0) {
 		return -1;
 	}
 
-	if (mbedtls_cipher_setkey(ctx, key, key_len * 8, operation) != 0) {
-		wpa_printf(MSG_ERROR, "mbedtls_cipher_setkey returned error");
+	if (esp_mbedtls_cipher_setkey(ctx, key, esp_key_len * 8, operation) != 0) {
+		wpa_printf(MSG_ERROR, "esp_mbedtls_cipher_setkey returned error");
 		return -1;
 	}
-	if (mbedtls_cipher_set_iv(ctx, iv, cipher_info->MBEDTLS_PRIVATE(iv_size)) != 0) {
-		wpa_printf(MSG_ERROR, "mbedtls_cipher_set_iv returned error");
+	if (esp_mbedtls_cipher_set_iv(ctx, iv, cipher_info->MBEDTLS_PRIVATE(iv_size)) != 0) {
+		wpa_printf(MSG_ERROR, "esp_mbedtls_cipher_set_iv returned error");
 		return -1;
 	}
-	if (mbedtls_cipher_reset(ctx) != 0) {
-		wpa_printf(MSG_ERROR, "mbedtls_cipher_reset() returned error");
+	if (esp_mbedtls_cipher_reset(ctx) != 0) {
+		wpa_printf(MSG_ERROR, "esp_mbedtls_cipher_reset() returned error");
 		return -1;
 	}
 
@@ -518,17 +518,17 @@ static int crypto_init_cipher_ctx(mbedtls_cipher_context_t *ctx,
 }
 
 static mbedtls_cipher_type_t alg_to_mbedtls_cipher(enum crypto_cipher_alg alg,
-						   size_t key_len)
+						   size_t esp_key_len)
 {
 	switch (alg) {
 	case CRYPTO_CIPHER_ALG_AES:
-		if (key_len == 16) {
+		if (esp_key_len == 16) {
 			return MBEDTLS_CIPHER_AES_128_CBC;
 		}
-		if (key_len == 24) {
+		if (esp_key_len == 24) {
 			return MBEDTLS_CIPHER_AES_192_CBC;
 		}
-		if (key_len == 32) {
+		if (esp_key_len == 32) {
 			return MBEDTLS_CIPHER_AES_256_CBC;
 		}
 		break;
@@ -547,7 +547,7 @@ static mbedtls_cipher_type_t alg_to_mbedtls_cipher(enum crypto_cipher_alg alg,
 
 struct crypto_cipher *crypto_cipher_init(enum crypto_cipher_alg alg,
 					 const u8 *iv, const u8 *key,
-					 size_t key_len)
+					 size_t esp_key_len)
 {
 	struct crypto_cipher *ctx;
 	mbedtls_cipher_type_t cipher_type;
@@ -558,31 +558,31 @@ struct crypto_cipher *crypto_cipher_init(enum crypto_cipher_alg alg,
 		return NULL;
 	}
 
-	cipher_type = alg_to_mbedtls_cipher(alg, key_len);
+	cipher_type = alg_to_mbedtls_cipher(alg, esp_key_len);
 	if (cipher_type == MBEDTLS_CIPHER_NONE) {
 		goto cleanup;
 	}
 
-	cipher_info = mbedtls_cipher_info_from_type(cipher_type);
+	cipher_info = esp_mbedtls_cipher_info_from_type(cipher_type);
 	if (cipher_info == NULL) {
 		goto cleanup;
 	}
 
 	/* Init both ctx encryption/decryption */
 	if (crypto_init_cipher_ctx(&ctx->ctx_enc, cipher_info, iv, key,
-				   key_len, MBEDTLS_ENCRYPT) < 0) {
+				   esp_key_len, MBEDTLS_ENCRYPT) < 0) {
 		goto cleanup;
 	}
 
 	if (crypto_init_cipher_ctx(&ctx->ctx_dec, cipher_info, iv, key,
-				   key_len, MBEDTLS_DECRYPT) < 0) {
+				   esp_key_len, MBEDTLS_DECRYPT) < 0) {
 		goto cleanup;
 	}
 
-	if (mbedtls_cipher_set_padding_mode(&ctx->ctx_enc, MBEDTLS_PADDING_NONE) < 0) {
+	if (esp_mbedtls_cipher_set_padding_mode(&ctx->ctx_enc, MBEDTLS_PADDING_NONE) < 0) {
 		goto cleanup;
 	}
-	if (mbedtls_cipher_set_padding_mode(&ctx->ctx_dec, MBEDTLS_PADDING_NONE) < 0) {
+	if (esp_mbedtls_cipher_set_padding_mode(&ctx->ctx_dec, MBEDTLS_PADDING_NONE) < 0) {
 		goto cleanup;
 	}
 	return ctx;
@@ -598,12 +598,12 @@ int crypto_cipher_encrypt(struct crypto_cipher *ctx, const u8 *plain,
 	int ret;
 	size_t olen = 0;
 
-	ret = mbedtls_cipher_update(&ctx->ctx_enc, plain, len, crypt, &olen);
+	ret = esp_mbedtls_cipher_update(&ctx->ctx_enc, plain, len, crypt, &olen);
 	if (ret != 0) {
 		return -1;
 	}
 
-	ret = mbedtls_cipher_finish(&ctx->ctx_enc, crypt + olen, &olen);
+	ret = esp_mbedtls_cipher_finish(&ctx->ctx_enc, crypt + olen, &olen);
 	if (ret != 0) {
 		return -1;
 	}
@@ -617,12 +617,12 @@ int crypto_cipher_decrypt(struct crypto_cipher *ctx, const u8 *crypt,
 	int ret;
 	size_t olen = 0;
 
-	ret = mbedtls_cipher_update(&ctx->ctx_dec, crypt, len, plain, &olen);
+	ret = esp_mbedtls_cipher_update(&ctx->ctx_dec, crypt, len, plain, &olen);
 	if (ret != 0) {
 		return -1;
 	}
 
-	ret = mbedtls_cipher_finish(&ctx->ctx_dec, plain + olen, &olen);
+	ret = esp_mbedtls_cipher_finish(&ctx->ctx_dec, plain + olen, &olen);
 	if (ret != 0) {
 		return -1;
 	}
@@ -632,13 +632,13 @@ int crypto_cipher_decrypt(struct crypto_cipher *ctx, const u8 *crypt,
 
 void crypto_cipher_deinit(struct crypto_cipher *ctx)
 {
-	mbedtls_cipher_free(&ctx->ctx_enc);
-	mbedtls_cipher_free(&ctx->ctx_dec);
+	esp_mbedtls_cipher_free(&ctx->ctx_enc);
+	esp_mbedtls_cipher_free(&ctx->ctx_dec);
 	os_free(ctx);
 }
 #endif
 
-int aes_ctr_encrypt(const u8 *key, size_t key_len, const u8 *nonce,
+int aes_ctr_encrypt(const u8 *key, size_t esp_key_len, const u8 *nonce,
 		    u8 *data, size_t data_len)
 {
 	int ret;
@@ -646,15 +646,15 @@ int aes_ctr_encrypt(const u8 *key, size_t key_len, const u8 *nonce,
 	uint8_t stream_block[MBEDTLS_AES_BLOCK_SIZE];
 	size_t offset = 0;
 
-	mbedtls_aes_init(&ctx);
-	ret = mbedtls_aes_setkey_enc(&ctx, key, key_len * 8);
+	esp_mbedtls_aes_init(&ctx);
+	ret = esp_mbedtls_aes_setkey_enc(&ctx, key, esp_key_len * 8);
 	if (ret < 0) {
 		goto cleanup;
 	}
-	ret = mbedtls_aes_crypt_ctr(&ctx, data_len, &offset, (u8 *)nonce,
+	ret = esp_mbedtls_aes_crypt_ctr(&ctx, data_len, &offset, (u8 *)nonce,
 				    stream_block, data, data);
 cleanup:
-	mbedtls_aes_free(&ctx);
+	esp_mbedtls_aes_free(&ctx);
 	return ret;
 }
 
@@ -671,18 +671,18 @@ int aes_wrap(const u8 *kek, size_t kek_len, int n, const u8 *plain, u8 *cipher)
 	mbedtls_nist_kw_context ctx;
 	size_t olen;
 	int ret = 0;
-	mbedtls_nist_kw_init(&ctx);
+	esp_mbedtls_nist_kw_init(&ctx);
 
-	ret = mbedtls_nist_kw_setkey(&ctx, MBEDTLS_CIPHER_ID_AES,
+	ret = esp_mbedtls_nist_kw_setkey(&ctx, MBEDTLS_CIPHER_ID_AES,
 			kek, kek_len * 8, 1);
 	if (ret != 0) {
 		return ret;
 	}
 
-	ret = mbedtls_nist_kw_wrap(&ctx, MBEDTLS_KW_MODE_KW, plain,
+	ret = esp_mbedtls_nist_kw_wrap(&ctx, MBEDTLS_KW_MODE_KW, plain,
 			n * 8, cipher, &olen, (n + 1) * 8);
 
-	mbedtls_nist_kw_free(&ctx);
+	esp_mbedtls_nist_kw_free(&ctx);
 	return ret;
 }
 
@@ -692,18 +692,18 @@ int aes_unwrap(const u8 *kek, size_t kek_len, int n, const u8 *cipher,
 	mbedtls_nist_kw_context ctx;
 	size_t olen;
 	int ret = 0;
-	mbedtls_nist_kw_init(&ctx);
+	esp_mbedtls_nist_kw_init(&ctx);
 
-	ret = mbedtls_nist_kw_setkey(&ctx, MBEDTLS_CIPHER_ID_AES,
+	ret = esp_mbedtls_nist_kw_setkey(&ctx, MBEDTLS_CIPHER_ID_AES,
 			kek, kek_len * 8, 0);
 	if (ret != 0) {
 		return ret;
 	}
 
-	ret = mbedtls_nist_kw_unwrap(&ctx, MBEDTLS_KW_MODE_KW, cipher,
+	ret = esp_mbedtls_nist_kw_unwrap(&ctx, MBEDTLS_KW_MODE_KW, cipher,
 			(n + 1) * 8, plain, &olen, (n * 8));
 
-	mbedtls_nist_kw_free(&ctx);
+	esp_mbedtls_nist_kw_free(&ctx);
 	return ret;
 }
 #endif
@@ -716,27 +716,27 @@ int crypto_mod_exp(const uint8_t *base, size_t base_len,
 	mbedtls_mpi bn_base, bn_exp, bn_modulus, bn_result, bn_rinv;
 	int ret = 0;
 
-	mbedtls_mpi_init(&bn_base);
-	mbedtls_mpi_init(&bn_exp);
-	mbedtls_mpi_init(&bn_modulus);
-	mbedtls_mpi_init(&bn_result);
-	mbedtls_mpi_init(&bn_rinv);
+	esp_mbedtls_mpi_init(&bn_base);
+	esp_mbedtls_mpi_init(&bn_exp);
+	esp_mbedtls_mpi_init(&bn_modulus);
+	esp_mbedtls_mpi_init(&bn_result);
+	esp_mbedtls_mpi_init(&bn_rinv);
 
-	MBEDTLS_MPI_CHK(mbedtls_mpi_read_binary(&bn_base, base, base_len));
-	MBEDTLS_MPI_CHK(mbedtls_mpi_read_binary(&bn_exp, power, power_len));
-	MBEDTLS_MPI_CHK(mbedtls_mpi_read_binary(&bn_modulus, modulus, modulus_len));
+	MBEDTLS_MPI_CHK(esp_mbedtls_mpi_read_binary(&bn_base, base, base_len));
+	MBEDTLS_MPI_CHK(esp_mbedtls_mpi_read_binary(&bn_exp, power, power_len));
+	MBEDTLS_MPI_CHK(esp_mbedtls_mpi_read_binary(&bn_modulus, modulus, modulus_len));
 
-	MBEDTLS_MPI_CHK(mbedtls_mpi_exp_mod(&bn_result, &bn_base, &bn_exp, &bn_modulus,
+	MBEDTLS_MPI_CHK(esp_mbedtls_mpi_exp_mod(&bn_result, &bn_base, &bn_exp, &bn_modulus,
 					    &bn_rinv));
 
-	ret = mbedtls_mpi_write_binary(&bn_result, result, *result_len);
+	ret = esp_mbedtls_mpi_write_binary(&bn_result, result, *result_len);
 
 cleanup:
-	mbedtls_mpi_free(&bn_base);
-	mbedtls_mpi_free(&bn_exp);
-	mbedtls_mpi_free(&bn_modulus);
-	mbedtls_mpi_free(&bn_result);
-	mbedtls_mpi_free(&bn_rinv);
+	esp_mbedtls_mpi_free(&bn_base);
+	esp_mbedtls_mpi_free(&bn_exp);
+	esp_mbedtls_mpi_free(&bn_modulus);
+	esp_mbedtls_mpi_free(&bn_result);
+	esp_mbedtls_mpi_free(&bn_rinv);
 
 	return ret;
 }
@@ -749,20 +749,20 @@ int pbkdf2_sha1(const char *passphrase, const u8 *ssid, size_t ssid_len,
 	const mbedtls_md_info_t *info_sha1;
 	int ret;
 
-	mbedtls_md_init(&sha1_ctx);
+	esp_mbedtls_md_init(&sha1_ctx);
 
-	info_sha1 = mbedtls_md_info_from_type(MBEDTLS_MD_SHA1);
+	info_sha1 = esp_mbedtls_md_info_from_type(MBEDTLS_MD_SHA1);
 	if (info_sha1 == NULL) {
 		ret = -1;
 		goto cleanup;
 	}
 
-	if ((ret = mbedtls_md_setup(&sha1_ctx, info_sha1, 1)) != 0) {
+	if ((ret = esp_mbedtls_md_setup(&sha1_ctx, info_sha1, 1)) != 0) {
 		ret = -1;
 		goto cleanup;
 	}
 
-	ret = mbedtls_pkcs5_pbkdf2_hmac(&sha1_ctx, (const u8 *) passphrase,
+	ret = esp_mbedtls_pkcs5_pbkdf2_hmac(&sha1_ctx, (const u8 *) passphrase,
 					os_strlen(passphrase) , ssid,
 					ssid_len, iterations, 32, buf);
 	if (ret != 0) {
@@ -771,7 +771,7 @@ int pbkdf2_sha1(const char *passphrase, const u8 *ssid, size_t ssid_len,
 	}
 
 cleanup:
-	mbedtls_md_free(&sha1_ctx);
+	esp_mbedtls_md_free(&sha1_ctx);
 	return ret;
 }
 
@@ -792,13 +792,13 @@ int des_encrypt(const u8 *clear, const u8 *key, u8 *cypher)
 	}
 	pkey[i] = next | 1;
 
-	mbedtls_des_init(&des);
-	ret = mbedtls_des_setkey_enc(&des, pkey);
+	esp_mbedtls_des_init(&des);
+	ret = esp_mbedtls_des_setkey_enc(&des, pkey);
 	if (ret < 0) {
 		return ret;
 	}
-	ret = mbedtls_des_crypt_ecb(&des, clear, cypher);
-	mbedtls_des_free(&des);
+	ret = esp_mbedtls_des_crypt_ecb(&des, clear, cypher);
+	esp_mbedtls_des_free(&des);
 
 	return ret;
 }
@@ -806,32 +806,32 @@ int des_encrypt(const u8 *clear, const u8 *key, u8 *cypher)
 
 /* Only enable this if all other ciphers are using MbedTLS implementation */
 #if defined(MBEDTLS_CCM_C) && defined(MBEDTLS_CMAC_C) && defined(MBEDTLS_NIST_KW_C)
-int aes_ccm_ae(const u8 *key, size_t key_len, const u8 *nonce,
+int aes_ccm_ae(const u8 *key, size_t esp_key_len, const u8 *nonce,
 	       size_t M, const u8 *plain, size_t plain_len,
 	       const u8 *aad, size_t aad_len, u8 *crypt, u8 *auth)
 {
 	int ret;
 	mbedtls_ccm_context ccm;
 
-	mbedtls_ccm_init(&ccm);
+	esp_mbedtls_ccm_init(&ccm);
 
-	ret = mbedtls_ccm_setkey(&ccm, MBEDTLS_CIPHER_ID_AES,
-				 key, key_len * 8);
+	ret = esp_mbedtls_ccm_setkey(&ccm, MBEDTLS_CIPHER_ID_AES,
+				 key, esp_key_len * 8);
 	if (ret < 0) {
-		wpa_printf(MSG_ERROR, "mbedtls_ccm_setkey failed");
+		wpa_printf(MSG_ERROR, "esp_mbedtls_ccm_setkey failed");
 		goto cleanup;
 	}
 
-	ret = mbedtls_ccm_encrypt_and_tag(&ccm, plain_len, nonce, 13, aad,
+	ret = esp_mbedtls_ccm_encrypt_and_tag(&ccm, plain_len, nonce, 13, aad,
 					  aad_len, plain, crypt, auth, M);
 
 cleanup:
-	mbedtls_ccm_free(&ccm);
+	esp_mbedtls_ccm_free(&ccm);
 
 	return ret;
 }
 
-int aes_ccm_ad(const u8 *key, size_t key_len, const u8 *nonce,
+int aes_ccm_ad(const u8 *key, size_t esp_key_len, const u8 *nonce,
 	       size_t M, const u8 *crypt, size_t crypt_len,
 	       const u8 *aad, size_t aad_len, const u8 *auth,
 	       u8 *plain)
@@ -839,27 +839,27 @@ int aes_ccm_ad(const u8 *key, size_t key_len, const u8 *nonce,
 	int ret;
 	mbedtls_ccm_context ccm;
 
-	mbedtls_ccm_init(&ccm);
+	esp_mbedtls_ccm_init(&ccm);
 
-	ret = mbedtls_ccm_setkey(&ccm, MBEDTLS_CIPHER_ID_AES,
-				 key, key_len * 8);
+	ret = esp_mbedtls_ccm_setkey(&ccm, MBEDTLS_CIPHER_ID_AES,
+				 key, esp_key_len * 8);
 	if (ret < 0) {
 		goto cleanup;;
 	}
 
-	ret = mbedtls_ccm_star_auth_decrypt(&ccm, crypt_len,
+	ret = esp_mbedtls_ccm_star_auth_decrypt(&ccm, crypt_len,
 					    nonce, 13, aad, aad_len,
 					    crypt, plain, auth, M);
 
 cleanup:
-	mbedtls_ccm_free(&ccm);
+	esp_mbedtls_ccm_free(&ccm);
 
 	return ret;
 }
 #endif
 
 #ifdef MBEDTLS_CMAC_C
-int omac1_aes_vector(const u8 *key, size_t key_len, size_t num_elem,
+int omac1_aes_vector(const u8 *key, size_t esp_key_len, size_t num_elem,
 		     const u8 *addr[], const size_t *len, u8 *mac)
 {
 	const mbedtls_cipher_info_t *cipher_info;
@@ -867,7 +867,7 @@ int omac1_aes_vector(const u8 *key, size_t key_len, size_t num_elem,
 	mbedtls_cipher_type_t cipher_type;
 	mbedtls_cipher_context_t ctx;
 
-	switch (key_len) {
+	switch (esp_key_len) {
 	case 16:
 		cipher_type = MBEDTLS_CIPHER_AES_128_ECB;
 		break;
@@ -881,7 +881,7 @@ int omac1_aes_vector(const u8 *key, size_t key_len, size_t num_elem,
 		cipher_type = MBEDTLS_CIPHER_NONE;
 		break;
 	}
-	cipher_info = mbedtls_cipher_info_from_type(cipher_type);
+	cipher_info = esp_mbedtls_cipher_info_from_type(cipher_type);
 	if (cipher_info == NULL) {
 		/* Failing at this point must be due to a build issue */
 		ret = MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE;
@@ -892,28 +892,28 @@ int omac1_aes_vector(const u8 *key, size_t key_len, size_t num_elem,
 		return -1;
 	}
 
-	mbedtls_cipher_init(&ctx);
+	esp_mbedtls_cipher_init(&ctx);
 
-	ret = mbedtls_cipher_setup(&ctx, cipher_info);
+	ret = esp_mbedtls_cipher_setup(&ctx, cipher_info);
 	if (ret != 0) {
 		goto cleanup;
 	}
 
-	ret = mbedtls_cipher_cmac_starts(&ctx, key, key_len * 8);
+	ret = esp_mbedtls_cipher_cmac_starts(&ctx, key, esp_key_len * 8);
 	if (ret != 0) {
 		goto cleanup;
 	}
 
 	for (i = 0 ; i < num_elem; i++) {
-		ret = mbedtls_cipher_cmac_update(&ctx, addr[i], len[i]);
+		ret = esp_mbedtls_cipher_cmac_update(&ctx, addr[i], len[i]);
 		if (ret != 0) {
 			goto cleanup;
 		}
 	}
 
-	ret = mbedtls_cipher_cmac_finish(&ctx, mac);
+	ret = esp_mbedtls_cipher_cmac_finish(&ctx, mac);
 cleanup:
-	mbedtls_cipher_free(&ctx);
+	esp_mbedtls_cipher_free(&ctx);
 	return(ret);
 }
 
diff --git a/components/wpa_supplicant/esp_supplicant/src/crypto/tls_mbedtls.c b/components/wpa_supplicant/esp_supplicant/src/crypto/tls_mbedtls.c
index 6c518eec22a5c3caf44f821f88d120afd9aa0984..17d9e9e054bc1d344e4d668220511f2024198eb1 100644
--- a/components/wpa_supplicant/esp_supplicant/src/crypto/tls_mbedtls.c
+++ b/components/wpa_supplicant/esp_supplicant/src/crypto/tls_mbedtls.c
@@ -87,13 +87,13 @@ static void tls_mbedtls_cleanup(tls_context_t *tls)
 		return;
 	}
 	tls->cacert_ptr = NULL;
-	mbedtls_x509_crt_free(&tls->cacert);
-	mbedtls_x509_crt_free(&tls->clientcert);
-	mbedtls_pk_free(&tls->clientkey);
-	mbedtls_entropy_free(&tls->entropy);
-	mbedtls_ssl_config_free(&tls->conf);
-	mbedtls_ctr_drbg_free(&tls->ctr_drbg);
-	mbedtls_ssl_free(&tls->ssl);
+	esp_mbedtls_x509_crt_free(&tls->cacert);
+	esp_mbedtls_x509_crt_free(&tls->clientcert);
+	esp_mbedtls_pk_free(&tls->clientkey);
+	esp_mbedtls_entropy_free(&tls->entropy);
+	esp_mbedtls_ssl_config_free(&tls->conf);
+	esp_mbedtls_ctr_drbg_free(&tls->ctr_drbg);
+	esp_mbedtls_ssl_free(&tls->ssl);
 }
 
 static void tls_mbedtls_conn_delete(tls_context_t *tls)
@@ -153,27 +153,27 @@ static int set_pki_context(tls_context_t *tls, const struct tls_connection_param
 		return -1;
 	}
 
-	mbedtls_x509_crt_init(&tls->clientcert);
-	mbedtls_pk_init(&tls->clientkey);
+	esp_mbedtls_x509_crt_init(&tls->clientcert);
+	esp_mbedtls_pk_init(&tls->clientkey);
 
-	ret = mbedtls_x509_crt_parse(&tls->clientcert,
+	ret = esp_mbedtls_x509_crt_parse(&tls->clientcert,
 				     cfg->client_cert_blob, cfg->client_cert_blob_len);
 	if (ret < 0) {
-		wpa_printf(MSG_ERROR, "mbedtls_x509_crt_parse returned -0x%x", -ret);
+		wpa_printf(MSG_ERROR, "esp_mbedtls_x509_crt_parse returned -0x%x", -ret);
 		return ret;
 	}
 
-	ret = mbedtls_pk_parse_key(&tls->clientkey, cfg->private_key_blob, cfg->private_key_blob_len,
+	ret = esp_mbedtls_pk_parse_key(&tls->clientkey, cfg->private_key_blob, cfg->private_key_blob_len,
 				   (const unsigned char *)cfg->private_key_passwd,
-				   cfg->private_key_passwd ? os_strlen(cfg->private_key_passwd) : 0, mbedtls_ctr_drbg_random, &tls->ctr_drbg);
+				   cfg->private_key_passwd ? os_strlen(cfg->private_key_passwd) : 0, esp_mbedtls_ctr_drbg_random, &tls->ctr_drbg);
 	if (ret < 0) {
-		wpa_printf(MSG_ERROR, "mbedtls_pk_parse_keyfile returned -0x%x", -ret);
+		wpa_printf(MSG_ERROR, "esp_mbedtls_pk_parse_keyfile returned -0x%x", -ret);
 		return ret;
 	}
 
-	ret = mbedtls_ssl_conf_own_cert(&tls->conf, &tls->clientcert, &tls->clientkey);
+	ret = esp_mbedtls_ssl_conf_own_cert(&tls->conf, &tls->clientcert, &tls->clientkey);
 	if (ret < 0) {
-		wpa_printf(MSG_ERROR, "mbedtls_ssl_conf_own_cert returned -0x%x", -ret);
+		wpa_printf(MSG_ERROR, "esp_mbedtls_ssl_conf_own_cert returned -0x%x", -ret);
 		return ret;
 	}
 
@@ -183,14 +183,14 @@ static int set_pki_context(tls_context_t *tls, const struct tls_connection_param
 static int set_ca_cert(tls_context_t *tls, const unsigned char *cacert, size_t cacert_len)
 {
 	tls->cacert_ptr = &tls->cacert;
-	mbedtls_x509_crt_init(tls->cacert_ptr);
-	int ret = mbedtls_x509_crt_parse(tls->cacert_ptr, cacert, cacert_len);
+	esp_mbedtls_x509_crt_init(tls->cacert_ptr);
+	int ret = esp_mbedtls_x509_crt_parse(tls->cacert_ptr, cacert, cacert_len);
 	if (ret < 0) {
-		wpa_printf(MSG_ERROR, "mbedtls_x509_crt_parse returned -0x%x", -ret);
+		wpa_printf(MSG_ERROR, "esp_mbedtls_x509_crt_parse returned -0x%x", -ret);
 		return ret;
 	}
-	mbedtls_ssl_conf_authmode(&tls->conf, MBEDTLS_SSL_VERIFY_REQUIRED);
-	mbedtls_ssl_conf_ca_chain(&tls->conf, tls->cacert_ptr, NULL);
+	esp_mbedtls_ssl_conf_authmode(&tls->conf, MBEDTLS_SSL_VERIFY_REQUIRED);
+	esp_mbedtls_ssl_conf_ca_chain(&tls->conf, tls->cacert_ptr, NULL);
 
 	return 0;
 }
@@ -225,8 +225,8 @@ const mbedtls_x509_crt_profile suiteb_mbedtls_x509_crt_profile =
 static void tls_set_suiteb_config(tls_context_t *tls)
 {
 	const mbedtls_x509_crt_profile *crt_profile = &suiteb_mbedtls_x509_crt_profile;
-	mbedtls_ssl_conf_cert_profile(&tls->conf, crt_profile);
-	mbedtls_ssl_conf_sig_algs(&tls->conf, tls_sig_algs_for_suiteb);
+	esp_mbedtls_ssl_conf_cert_profile(&tls->conf, crt_profile);
+	esp_mbedtls_ssl_conf_sig_algs(&tls->conf, tls_sig_algs_for_suiteb);
 }
 #endif
 
@@ -284,8 +284,8 @@ const mbedtls_x509_crt_profile eap_mbedtls_x509_crt_profile =
 static void tls_enable_sha1_config(tls_context_t *tls)
 {
 	const mbedtls_x509_crt_profile *crt_profile = &eap_mbedtls_x509_crt_profile;
-	mbedtls_ssl_conf_cert_profile(&tls->conf, crt_profile);
-	mbedtls_ssl_conf_sig_algs(&tls->conf, tls_sig_algs_for_eap);
+	esp_mbedtls_ssl_conf_cert_profile(&tls->conf, crt_profile);
+	esp_mbedtls_ssl_conf_sig_algs(&tls->conf, tls_sig_algs_for_eap);
 }
 
 static const int eap_ciphersuite_preference[] =
@@ -457,26 +457,26 @@ static void tls_set_ciphersuite(const struct tls_connection_params *cfg, tls_con
 #ifdef CONFIG_SUITEB192
 	if (cfg->flags & TLS_CONN_SUITEB) {
 		/* cipher suites will be set based on certificate */
-		mbedtls_pk_type_t pk_alg = mbedtls_pk_get_type(&tls->clientkey);
+		mbedtls_pk_type_t pk_alg = esp_mbedtls_pk_get_type(&tls->clientkey);
 		if (pk_alg == MBEDTLS_PK_RSA || pk_alg == MBEDTLS_PK_RSASSA_PSS) {
-			mbedtls_ssl_conf_ciphersuites(&tls->conf,
+			esp_mbedtls_ssl_conf_ciphersuites(&tls->conf,
 						      suiteb_rsa_ciphersuite_preference);
 		} else if (pk_alg == MBEDTLS_PK_ECDSA ||
 			   pk_alg == MBEDTLS_PK_ECKEY ||
 			   pk_alg == MBEDTLS_PK_ECKEY_DH) {
-			mbedtls_ssl_conf_ciphersuites(&tls->conf,
+			esp_mbedtls_ssl_conf_ciphersuites(&tls->conf,
 						      suiteb_ecc_ciphersuite_preference);
 		} else {
-			mbedtls_ssl_conf_ciphersuites(&tls->conf,
+			esp_mbedtls_ssl_conf_ciphersuites(&tls->conf,
 						      suiteb_ciphersuite_preference);
 		}
 	} else
 #endif
 	if (tls->ciphersuite[0]) {
-		mbedtls_ssl_conf_ciphersuites(&tls->conf, tls->ciphersuite);
-	} else if (mbedtls_pk_get_bitlen(&tls->clientkey) > 2048 ||
-		(tls->cacert_ptr && mbedtls_pk_get_bitlen(&tls->cacert_ptr->pk) > 2048)) {
-		mbedtls_ssl_conf_ciphersuites(&tls->conf, eap_ciphersuite_preference);
+		esp_mbedtls_ssl_conf_ciphersuites(&tls->conf, tls->ciphersuite);
+	} else if (esp_mbedtls_pk_get_bitlen(&tls->clientkey) > 2048 ||
+		(tls->cacert_ptr && esp_mbedtls_pk_get_bitlen(&tls->cacert_ptr->pk) > 2048)) {
+		esp_mbedtls_ssl_conf_ciphersuites(&tls->conf, eap_ciphersuite_preference);
 	}
 }
 
@@ -491,12 +491,12 @@ static int set_client_config(const struct tls_connection_params *cfg, tls_contex
 	if (cfg->flags & TLS_CONN_SUITEB)
 		preset = MBEDTLS_SSL_PRESET_SUITEB;
 #endif
-	ret = mbedtls_ssl_config_defaults(&tls->conf,
+	ret = esp_mbedtls_ssl_config_defaults(&tls->conf,
 					MBEDTLS_SSL_IS_CLIENT,
 					MBEDTLS_SSL_TRANSPORT_STREAM,
 					preset);
 	if (ret != 0) {
-		wpa_printf(MSG_ERROR, "mbedtls_ssl_config_defaults returned -0x%x", -ret);
+		wpa_printf(MSG_ERROR, "esp_mbedtls_ssl_config_defaults returned -0x%x", -ret);
 		return ret;
 	}
 
@@ -515,7 +515,7 @@ static int set_client_config(const struct tls_connection_params *cfg, tls_contex
 			return ret;
 		}
 	} else {
-		mbedtls_ssl_conf_authmode(&tls->conf, MBEDTLS_SSL_VERIFY_NONE);
+		esp_mbedtls_ssl_conf_authmode(&tls->conf, MBEDTLS_SSL_VERIFY_NONE);
 	}
 
 	if (cfg->client_cert_blob != NULL && cfg->private_key_blob != NULL) {
@@ -572,10 +572,10 @@ static int tls_create_mbedtls_handle(struct tls_connection *conn,
 	assert(params != NULL);
 	assert(tls != NULL);
 
-	mbedtls_ssl_init(&tls->ssl);
-	mbedtls_ctr_drbg_init(&tls->ctr_drbg);
-	mbedtls_ssl_config_init(&tls->conf);
-	mbedtls_entropy_init(&tls->entropy);
+	esp_mbedtls_ssl_init(&tls->ssl);
+	esp_mbedtls_ctr_drbg_init(&tls->ctr_drbg);
+	esp_mbedtls_ssl_config_init(&tls->conf);
+	esp_mbedtls_entropy_init(&tls->entropy);
 
 	ret = set_client_config(params, tls);
 	if (ret != 0) {
@@ -583,21 +583,21 @@ static int tls_create_mbedtls_handle(struct tls_connection *conn,
 		goto exit;
 	}
 
-	ret = mbedtls_ctr_drbg_seed(&tls->ctr_drbg, mbedtls_entropy_func,
+	ret = esp_mbedtls_ctr_drbg_seed(&tls->ctr_drbg, esp_mbedtls_entropy_func,
 				    &tls->entropy, NULL, 0);
 	if (ret != 0) {
-		wpa_printf(MSG_ERROR, "mbedtls_ctr_drbg_seed returned -0x%x", -ret);
+		wpa_printf(MSG_ERROR, "esp_mbedtls_ctr_drbg_seed returned -0x%x", -ret);
 		goto exit;
 	}
 
-	mbedtls_ssl_conf_rng(&tls->conf, mbedtls_ctr_drbg_random, &tls->ctr_drbg);
+	esp_mbedtls_ssl_conf_rng(&tls->conf, esp_mbedtls_ctr_drbg_random, &tls->ctr_drbg);
 
-	ret = mbedtls_ssl_setup(&tls->ssl, &tls->conf);
+	ret = esp_mbedtls_ssl_setup(&tls->ssl, &tls->conf);
 	if (ret != 0) {
-		wpa_printf(MSG_ERROR, "mbedtls_ssl_setup returned -0x%x", -ret);
+		wpa_printf(MSG_ERROR, "esp_mbedtls_ssl_setup returned -0x%x", -ret);
 		goto exit;
 	}
-	mbedtls_ssl_set_export_keys_cb(&tls->ssl, tls_key_derivation, conn);
+	esp_mbedtls_ssl_set_export_keys_cb(&tls->ssl, tls_key_derivation, conn);
 #if defined(MBEDTLS_SSL_CBC_RECORD_SPLITTING)
 	/* Disable BEAST attack countermeasures for Windows 2008 interoperability */
 	mbedtls_ssl_conf_cbc_record_splitting(&tls->conf, MBEDTLS_SSL_CBC_RECORD_SPLITTING_DISABLED);
@@ -705,7 +705,7 @@ struct wpabuf * tls_connection_handshake(void *tls_ctx,
 				conn->mac = tls->ssl.handshake->ciphersuite_info->mac;
 			}
 		}
-		ret = mbedtls_ssl_handshake_step(&tls->ssl);
+		ret = esp_mbedtls_ssl_handshake_step(&tls->ssl);
 
 		if (ret < 0)
 			break;
@@ -746,7 +746,7 @@ struct wpabuf * tls_connection_encrypt(void *tls_ctx,
 
 	/* Reset dangling pointer */
 	conn->tls_io_data.out_data = NULL;
-	ret = mbedtls_ssl_write(&conn->tls->ssl,
+	ret = esp_mbedtls_ssl_write(&conn->tls->ssl,
 			(unsigned char*) wpabuf_head(in_data),  wpabuf_len(in_data));
 
 	if (ret < wpabuf_len(in_data)) {
@@ -780,7 +780,7 @@ struct wpabuf *tls_connection_decrypt(void *tls_ctx,
 	if (!conn->tls_io_data.in_data) {
 		goto cleanup;
 	}
-	ret = mbedtls_ssl_read(&conn->tls->ssl, buf, MAX_PHASE2_BUFFER);
+	ret = esp_mbedtls_ssl_read(&conn->tls->ssl, buf, MAX_PHASE2_BUFFER);
 	if (ret < 0) {
 		wpa_printf(MSG_ERROR, "%s:%d, not able to read data",
 				__func__, __LINE__);
@@ -833,7 +833,7 @@ int tls_get_version(void *tls_ctx, struct tls_connection *conn,
 		return -1;
 	}
 
-	name = mbedtls_ssl_get_version(&conn->tls->ssl);
+	name = esp_mbedtls_ssl_get_version(&conn->tls->ssl);
 	if (name == NULL) {
 		return -1;
 	}
@@ -851,7 +851,7 @@ int tls_get_cipher(void *tls_ctx, struct tls_connection *conn,
 		return -1;
 	}
 
-	name = mbedtls_ssl_get_ciphersuite(&conn->tls->ssl);
+	name = esp_mbedtls_ssl_get_ciphersuite(&conn->tls->ssl);
 	if (name == NULL) {
 		return -1;
 	}
@@ -907,7 +907,7 @@ int tls_connection_set_params(void *tls_ctx, struct tls_connection *conn,
 		wpa_printf(MSG_ERROR, "failed to create ssl handle");
 		goto err;
 	}
-	mbedtls_ssl_set_bio(&tls->ssl, conn, tls_mbedtls_write, tls_mbedtls_read, NULL);
+	esp_mbedtls_ssl_set_bio(&tls->ssl, conn, tls_mbedtls_write, tls_mbedtls_read, NULL);
 	conn->tls = (tls_context_t *)tls;
 
 	return ret;
@@ -959,7 +959,7 @@ static int tls_connection_prf(void *tls_ctx, struct tls_connection *conn,
 	wpa_hexdump_key(MSG_MSGDUMP, "random", seed, 2 * TLS_RANDOM_LEN);
 	wpa_hexdump_key(MSG_MSGDUMP, "master", ssl->MBEDTLS_PRIVATE(session)->MBEDTLS_PRIVATE(master), TLS_MASTER_SECRET_LEN);
 
-	ret = mbedtls_ssl_tls_prf(conn->tls_prf_type, conn->master_secret, TLS_MASTER_SECRET_LEN,
+	ret = esp_mbedtls_ssl_tls_prf(conn->tls_prf_type, conn->master_secret, TLS_MASTER_SECRET_LEN,
 				label, seed, 2 * TLS_RANDOM_LEN, out, out_len);
 
 	if (ret < 0) {
@@ -1002,7 +1002,7 @@ int tls_connection_shutdown(void *tls_ctx, struct tls_connection *conn)
 	/* outdata may have dangling pointer */
 	conn->tls_io_data.out_data = NULL;
 
-	return mbedtls_ssl_session_reset(&conn->tls->ssl);
+	return esp_mbedtls_ssl_session_reset(&conn->tls->ssl);
 }
 
 int tls_connection_get_random(void *tls_ctx, struct tls_connection *conn,
diff --git a/components/wpa_supplicant/esp_supplicant/src/esp_common.c b/components/wpa_supplicant/esp_supplicant/src/esp_common.c
index 91ef416e72cf029f295ddac10402d72fd7707988..2d5fe14bcc5a79b1c42bfa24678ebd41f910538d 100644
--- a/components/wpa_supplicant/esp_supplicant/src/esp_common.c
+++ b/components/wpa_supplicant/esp_supplicant/src/esp_common.c
@@ -184,7 +184,7 @@ static void register_mgmt_frames(struct wpa_supplicant *wpa_s)
 	wpa_s->subtype = 0;
 
 #ifdef CONFIG_WPA_11KV_SUPPORT
-	/* current supported features in supplicant: rrm and btm */
+	/* current supported esp_features in supplicant: rrm and btm */
 	if (esp_wifi_is_rm_enabled_internal(WIFI_IF_STA))
 		wpa_s->subtype = 1 << WLAN_ACTION_RADIO_MEASUREMENT;
 	if (esp_wifi_is_btm_enabled_internal(WIFI_IF_STA))
diff --git a/components/wpa_supplicant/esp_supplicant/src/esp_wifi_driver.h b/components/wpa_supplicant/esp_supplicant/src/esp_wifi_driver.h
index e0b2b5de22bc6d6bd19a43b7f25d12ef8ab808cc..b7662e04373b9c5408aff2f8fda18edbb483be6b 100644
--- a/components/wpa_supplicant/esp_supplicant/src/esp_wifi_driver.h
+++ b/components/wpa_supplicant/esp_supplicant/src/esp_wifi_driver.h
@@ -226,11 +226,11 @@ void esp_wifi_deauthenticate_internal(u8 reason_code);
 uint16_t esp_wifi_get_spp_attrubute_internal(uint8_t ifx);
 bool esp_wifi_sta_is_running_internal(void);
 bool esp_wifi_auth_done_internal(void);
-int esp_wifi_set_ap_key_internal(int alg, const u8 *addr, int idx, u8 *key, size_t key_len);
+int esp_wifi_set_ap_key_internal(int alg, const u8 *addr, int idx, u8 *key, size_t esp_key_len);
 int esp_wifi_set_sta_key_internal(int alg, u8 *addr, int key_idx, int set_tx,
-                                  u8 *seq, size_t seq_len, u8 *key, size_t key_len, enum key_flag key_flag);
+                                  u8 *seq, size_t seq_len, u8 *key, size_t esp_key_len, enum key_flag key_flag);
 int  esp_wifi_get_sta_key_internal(uint8_t *ifx, int *alg, u8 *addr, int *key_idx,
-                                   u8 *key, size_t key_len, enum key_flag key_flag);
+                                   u8 *key, size_t esp_key_len, enum key_flag key_flag);
 bool esp_wifi_wpa_ptk_init_done_internal(uint8_t *mac);
 uint8_t esp_wifi_sta_set_reset_param_internal(uint8_t reset_flag);
 uint8_t esp_wifi_get_sta_gtk_index_internal(void);
diff --git a/components/wpa_supplicant/esp_supplicant/src/esp_wpa_main.c b/components/wpa_supplicant/esp_supplicant/src/esp_wpa_main.c
index 434d66bbc23bfaa129ec891b53e933114b0dab2a..8f62e5fd74abf7ea7742403f56d78a5d9fe9fada 100644
--- a/components/wpa_supplicant/esp_supplicant/src/esp_wpa_main.c
+++ b/components/wpa_supplicant/esp_supplicant/src/esp_wpa_main.c
@@ -42,15 +42,15 @@
 const wifi_osi_funcs_t *wifi_funcs;
 
 void  wpa_install_key(enum wpa_alg alg, u8 *addr, int key_idx, int set_tx,
-                      u8 *seq, size_t seq_len, u8 *key, size_t key_len, enum key_flag key_flag)
+                      u8 *seq, size_t seq_len, u8 *key, size_t esp_key_len, enum key_flag key_flag)
 {
-    esp_wifi_set_sta_key_internal(alg, addr, key_idx, set_tx, seq, seq_len, key, key_len, key_flag);
+    esp_wifi_set_sta_key_internal(alg, addr, key_idx, set_tx, seq, seq_len, key, esp_key_len, key_flag);
 }
 
 int  wpa_get_key(uint8_t *ifx, int *alg, u8 *addr, int *key_idx,
-                 u8 *key, size_t key_len, enum key_flag key_flag)
+                 u8 *key, size_t esp_key_len, enum key_flag key_flag)
 {
-    return esp_wifi_get_sta_key_internal(ifx, alg, addr, key_idx, key, key_len, key_flag);
+    return esp_wifi_get_sta_key_internal(ifx, alg, addr, key_idx, key, esp_key_len, key_flag);
 }
 
 /**
diff --git a/components/wpa_supplicant/esp_supplicant/src/esp_wps.c b/components/wpa_supplicant/esp_supplicant/src/esp_wps.c
index ac621e435b20f63690036bdff3193ebb656de2b7..2d479b0e3db90d306eb277c1fb5f19cd0f6c3018 100644
--- a/components/wpa_supplicant/esp_supplicant/src/esp_wps.c
+++ b/components/wpa_supplicant/esp_supplicant/src/esp_wps.c
@@ -786,7 +786,7 @@ int wps_finish(void)
             }
 
             os_memcpy(config->sta.ssid, sm->ssid[0], sm->ssid_len[0]);
-            os_memcpy(config->sta.password, sm->key[0], sm->key_len[0]);
+            os_memcpy(config->sta.password, sm->key[0], sm->esp_key_len[0]);
             os_memcpy(config->sta.bssid, sm->bssid, ETH_ALEN);
             config->sta.bssid_set = 0;
             esp_wifi_set_config(0, config);
@@ -1289,7 +1289,7 @@ void wifi_station_wps_success_internal(void)
         evt.ap_cred_cnt = sm->ap_cred_cnt;
         for (i = 0; i < MAX_WPS_AP_CRED; i++) {
             os_memcpy(evt.ap_cred[i].ssid, sm->ssid[i], sm->ssid_len[i]);
-            os_memcpy(evt.ap_cred[i].passphrase, sm->key[i], sm->key_len[i]);
+            os_memcpy(evt.ap_cred[i].passphrase, sm->key[i], sm->esp_key_len[i]);
         }
         esp_event_post(WIFI_EVENT, WIFI_EVENT_STA_WPS_ER_SUCCESS, &evt,
                                 sizeof(evt), OS_BLOCK);
@@ -1336,13 +1336,13 @@ static int save_credentials_cb(void *ctx, const struct wps_credential *cred)
 
     os_memcpy(gWpsSm->ssid[gWpsSm->ap_cred_cnt], cred->ssid, cred->ssid_len);
     gWpsSm->ssid_len[gWpsSm->ap_cred_cnt] = cred->ssid_len;
-    os_memcpy(gWpsSm->key[gWpsSm->ap_cred_cnt], cred->key, cred->key_len);
-    gWpsSm->key_len[gWpsSm->ap_cred_cnt] = cred->key_len;
+    os_memcpy(gWpsSm->key[gWpsSm->ap_cred_cnt], cred->key, cred->esp_key_len);
+    gWpsSm->esp_key_len[gWpsSm->ap_cred_cnt] = cred->esp_key_len;
 
     gWpsSm->ap_cred_cnt++;
 
     wpa_hexdump_ascii(MSG_DEBUG, "ssid ", cred->ssid, cred->ssid_len);
-    wpa_hexdump_ascii(MSG_DEBUG, "key ", cred->key, cred->key_len);
+    wpa_hexdump_ascii(MSG_DEBUG, "key ", cred->key, cred->esp_key_len);
 
     return ESP_OK;
 }
diff --git a/components/wpa_supplicant/esp_supplicant/src/esp_wps_i.h b/components/wpa_supplicant/esp_supplicant/src/esp_wps_i.h
index 7ad0e293b6ed5438d8d40da5788ddff24d64716f..b432b0759735004db4016447c382bbd3caf9e7e2 100644
--- a/components/wpa_supplicant/esp_supplicant/src/esp_wps_i.h
+++ b/components/wpa_supplicant/esp_supplicant/src/esp_wps_i.h
@@ -57,7 +57,7 @@ struct wps_sm {
     u8 ssid[MAX_CRED_COUNT][SSID_MAX_LEN];
     u8 ssid_len[MAX_CRED_COUNT];
     char key[MAX_CRED_COUNT][MAX_PASSPHRASE_LEN];
-    u8 key_len[MAX_CRED_COUNT];
+    u8 esp_key_len[MAX_CRED_COUNT];
     u8 ap_cred_cnt;
     struct wps_device_data *dev;
     u8 uuid[16];
diff --git a/components/wpa_supplicant/port/include/os.h b/components/wpa_supplicant/port/include/os.h
index 06c4c176ab6933af3eac8e7b6f4afb504d15884a..dbd91af7afa92dd21bb944423f284a7ac50dd11b 100644
--- a/components/wpa_supplicant/port/include/os.h
+++ b/components/wpa_supplicant/port/include/os.h
@@ -328,12 +328,12 @@ void forced_memzero(void *ptr, size_t len);
  * try go a bit further by storing the first octet (now zero) to make this even
  * a bit more difficult to optimize out. Once memset_s() is available, that
  * could be used here instead. */
-static void * (* const volatile memset_func)(void *, int, size_t) = memset;
+static void * (* const volatile esp_memset_func)(void *, int, size_t) = memset;
 static uint8_t forced_memzero_val;
 
 static inline void forced_memzero(void *ptr, size_t len)
 {
-	memset_func(ptr, 0, len);
+	esp_memset_func(ptr, 0, len);
 	if (len) {
 		forced_memzero_val = ((uint8_t *) ptr)[0];
 	}
diff --git a/components/wpa_supplicant/port/os_xtensa.c b/components/wpa_supplicant/port/os_xtensa.c
index 7a2309e8b5b018f0baafe1e7599898559b298b4c..2f522eb30ea58f56f5c63792448cd0a731effd8a 100644
--- a/components/wpa_supplicant/port/os_xtensa.c
+++ b/components/wpa_supplicant/port/os_xtensa.c
@@ -63,6 +63,6 @@ void os_sleep(os_time_t sec, os_time_t usec)
 #ifdef CONFIG_CRYPTO_MBEDTLS
 void forced_memzero(void *ptr, size_t len)
 {
-    mbedtls_platform_zeroize(ptr, len);
+    esp_mbedtls_platform_zeroize(ptr, len);
 }
 #endif
diff --git a/components/wpa_supplicant/src/ap/wpa_auth.c b/components/wpa_supplicant/src/ap/wpa_auth.c
index cfd3d04b40f1b6c11b6b6a8c0202b92be695e7b9..64c8c102640f5bb336379a8407c7fade2f9099c2 100644
--- a/components/wpa_supplicant/src/ap/wpa_auth.c
+++ b/components/wpa_supplicant/src/ap/wpa_auth.c
@@ -139,7 +139,7 @@ static inline int wpa_auth_get_msk(struct wpa_authenticator *wpa_auth,
 static inline int wpa_auth_set_key(struct wpa_authenticator *wpa_auth,
                    int vlan_id,
                    enum wpa_alg alg, const u8 *addr, int idx,
-                   u8 *key, size_t key_len)
+                   u8 *key, size_t esp_key_len)
 {
     int ret;
 
@@ -166,8 +166,8 @@ static inline int wpa_auth_set_key(struct wpa_authenticator *wpa_auth,
             return -1;
 	}
     } else {
-	wpa_printf( MSG_DEBUG, "%s : key idx  %d alg %d vlan_id %d key_len %d key \n", __func__, idx, alg, vlan_id, key_len);
-	return esp_wifi_set_ap_key_internal(alg, addr, idx, key, key_len);
+	wpa_printf( MSG_DEBUG, "%s : key idx  %d alg %d vlan_id %d esp_key_len %d key \n", __func__, idx, alg, vlan_id, esp_key_len);
+	return esp_wifi_set_ap_key_internal(alg, addr, idx, key, esp_key_len);
     }
     return 0;
 }
diff --git a/components/wpa_supplicant/src/ap/wpa_auth.h b/components/wpa_supplicant/src/ap/wpa_auth.h
index a4a040fd27d73965b61c7437a77a13253d38de36..11581493a9ec38dd9a6cb9d926259228ff7aaccb 100644
--- a/components/wpa_supplicant/src/ap/wpa_auth.h
+++ b/components/wpa_supplicant/src/ap/wpa_auth.h
@@ -186,7 +186,7 @@ struct wpa_auth_callbacks {
 	const u8 * (*get_psk)(void *ctx, const u8 *addr, const u8 *prev_psk);
 	int (*get_msk)(void *ctx, const u8 *addr, u8 *msk, size_t *len);
 	int (*set_key)(void *ctx, int vlan_id, enum wpa_alg alg,
-		       const u8 *addr, int idx, u8 *key, size_t key_len);
+		       const u8 *addr, int idx, u8 *key, size_t esp_key_len);
 	int (*get_seqnum)(void *ctx, const u8 *addr, int idx, u8 *seq);
 	int (*send_eapol)(void *ctx, const u8 *addr, const u8 *data,
 			  size_t data_len, int encrypt);
diff --git a/components/wpa_supplicant/src/ap/wps_hostapd.c b/components/wpa_supplicant/src/ap/wps_hostapd.c
index 3210438f94305046cd459c3c6981fc41e65a788b..147f12f312be9a8ae8b032267de575ddb4c9fea9 100644
--- a/components/wpa_supplicant/src/ap/wps_hostapd.c
+++ b/components/wpa_supplicant/src/ap/wps_hostapd.c
@@ -513,8 +513,8 @@ int hostapd_wps_config_ap(struct hostapd_data *hapd, struct wps_data *wps_data)
 	}
 
 	if (hapd->conf->ssid.wpa_passphrase) {
-		cred.key_len = os_strlen(hapd->conf->ssid.wpa_passphrase);
-		memcpy(cred.key, hapd->conf->ssid.wpa_passphrase, cred.key_len);
+		cred.esp_key_len = os_strlen(hapd->conf->ssid.wpa_passphrase);
+		memcpy(cred.key, hapd->conf->ssid.wpa_passphrase, cred.esp_key_len);
 	}
 	wps_data->use_cred = os_malloc(sizeof(struct wps_credential));
 	if (!wps_data->use_cred) {
diff --git a/components/wpa_supplicant/src/common/dpp.c b/components/wpa_supplicant/src/common/dpp.c
index 887add165f30454bd53c5a95c39e2e78bbafb9b6..a5b85100cffb7ad5ba40661d96c77f69fe9bb533 100644
--- a/components/wpa_supplicant/src/common/dpp.c
+++ b/components/wpa_supplicant/src/common/dpp.c
@@ -130,35 +130,35 @@ static int dpp_hkdf_expand(size_t hash_len, const u8 *secret, size_t secret_len,
 }
 
 
-static int dpp_hmac_vector(size_t hash_len, const u8 *key, size_t key_len,
+static int dpp_hmac_vector(size_t hash_len, const u8 *key, size_t esp_key_len,
 			   size_t num_elem, const u8 *addr[],
 			   const size_t *len, u8 *mac)
 {
 	if (hash_len == 32)
-		return hmac_sha256_vector(key, key_len, num_elem, addr, len,
+		return hmac_sha256_vector(key, esp_key_len, num_elem, addr, len,
 					  mac);
 #ifndef ESP_SUPPLICANT
 	if (hash_len == 48)
-		return hmac_sha384_vector(key, key_len, num_elem, addr, len,
+		return hmac_sha384_vector(key, esp_key_len, num_elem, addr, len,
 					  mac);
 	if (hash_len == 64)
-		return hmac_sha512_vector(key, key_len, num_elem, addr, len,
+		return hmac_sha512_vector(key, esp_key_len, num_elem, addr, len,
 					  mac);
 #endif
 	return -1;
 }
 
 
-static int dpp_hmac(size_t hash_len, const u8 *key, size_t key_len,
+static int dpp_hmac(size_t hash_len, const u8 *key, size_t esp_key_len,
 		    const u8 *data, size_t data_len, u8 *mac)
 {
 	if (hash_len == 32)
-		return hmac_sha256(key, key_len, data, data_len, mac);
+		return hmac_sha256(key, esp_key_len, data, data_len, mac);
 #ifndef ESP_SUPPLICANT
 	if (hash_len == 48)
-		return hmac_sha384(key, key_len, data, data_len, mac);
+		return hmac_sha384(key, esp_key_len, data, data_len, mac);
 	if (hash_len == 64)
-		return hmac_sha512(key, key_len, data, data_len, mac);
+		return hmac_sha512(key, esp_key_len, data, data_len, mac);
 #endif
 	return -1;
 }
@@ -625,7 +625,7 @@ static struct dpp_bootstrap_info * dpp_parse_uri(const char *uri)
 			mac = pos + 2;
 		else if (pos[0] == 'I' && pos[1] == ':' && !info)
 			info = pos + 2;
-		else if (pos[0] == 'K' && pos[1] == ':' && !pk)
+		else if (pos[0] == 'esp_K' && pos[1] == ':' && !pk)
 			pk = pos + 2;
 		else
 			wpa_hexdump_ascii(MSG_DEBUG,
@@ -1493,7 +1493,7 @@ static int dpp_autogen_bootstrap_key(struct dpp_authentication *auth)
 	bi->uri = os_malloc(len + 1);
 	if (!bi->uri)
 		goto fail;
-	os_snprintf(bi->uri, len + 1, "DPP:K:%s;;", pk);
+	os_snprintf(bi->uri, len + 1, "DPP:esp_K:%s;;", pk);
 	wpa_printf(MSG_DEBUG,
 		   "DPP: Auto-generated own bootstrapping key info: URI %s",
 		   bi->uri);
diff --git a/components/wpa_supplicant/src/common/sae.c b/components/wpa_supplicant/src/common/sae.c
index 3d04995327f7450a8ceaaa39613e0a9ac3e0b550..47212cdb3a8b5e163c174516b64f459ebd8f0672 100644
--- a/components/wpa_supplicant/src/common/sae.c
+++ b/components/wpa_supplicant/src/common/sae.c
@@ -1422,28 +1422,28 @@ int sae_prepare_commit_pt(struct sae_data *sae, struct sae_pt *pt,
 
 static int sae_derive_k_ecc(struct sae_data *sae, u8 *k)
 {
-	struct crypto_ec_point *K;
+	struct crypto_ec_point *esp_K;
 	int ret = -1;
 
-	K = crypto_ec_point_init(sae->tmp->ec);
-	if (K == NULL)
+	esp_K = crypto_ec_point_init(sae->tmp->ec);
+	if (esp_K == NULL)
 		goto fail;
 
 	/*
-	 * K = scalar-op(rand, (elem-op(scalar-op(peer-commit-scalar, PWE),
+	 * esp_K = scalar-op(rand, (elem-op(scalar-op(peer-commit-scalar, PWE),
 	 *                                        PEER-COMMIT-ELEMENT)))
-	 * If K is identity element (point-at-infinity), reject
-	 * k = F(K) (= x coordinate)
+	 * If esp_K is identity element (point-at-infinity), reject
+	 * k = F(esp_K) (= x coordinate)
 	 */
 
 	if (crypto_ec_point_mul(sae->tmp->ec, sae->tmp->pwe_ecc,
-				sae->peer_commit_scalar, K) < 0 ||
-	    crypto_ec_point_add(sae->tmp->ec, K,
-				sae->tmp->peer_commit_element_ecc, K) < 0 ||
-	    crypto_ec_point_mul(sae->tmp->ec, K, sae->tmp->sae_rand, K) < 0 ||
-	    crypto_ec_point_is_at_infinity(sae->tmp->ec, K) ||
-	    crypto_ec_point_to_bin(sae->tmp->ec, K, k, NULL) < 0) {
-		wpa_printf(MSG_DEBUG, "SAE: Failed to calculate K and k");
+				sae->peer_commit_scalar, esp_K) < 0 ||
+	    crypto_ec_point_add(sae->tmp->ec, esp_K,
+				sae->tmp->peer_commit_element_ecc, esp_K) < 0 ||
+	    crypto_ec_point_mul(sae->tmp->ec, esp_K, sae->tmp->sae_rand, esp_K) < 0 ||
+	    crypto_ec_point_is_at_infinity(sae->tmp->ec, esp_K) ||
+	    crypto_ec_point_to_bin(sae->tmp->ec, esp_K, k, NULL) < 0) {
+		wpa_printf(MSG_DEBUG, "SAE: Failed to calculate esp_K and k");
 		goto fail;
 	}
 
@@ -1451,36 +1451,36 @@ static int sae_derive_k_ecc(struct sae_data *sae, u8 *k)
 
 	ret = 0;
 fail:
-	crypto_ec_point_deinit(K, 1);
+	crypto_ec_point_deinit(esp_K, 1);
 	return ret;
 }
 
 static int sae_derive_k_ffc(struct sae_data *sae, u8 *k)
 {
-	struct crypto_bignum *K;
+	struct crypto_bignum *esp_K;
 	int ret = -1;
 
-	K = crypto_bignum_init();
-	if (K == NULL)
+	esp_K = crypto_bignum_init();
+	if (esp_K == NULL)
 		goto fail;
 
 	/*
-	 * K = scalar-op(rand, (elem-op(scalar-op(peer-commit-scalar, PWE),
+	 * esp_K = scalar-op(rand, (elem-op(scalar-op(peer-commit-scalar, PWE),
 	 *                                        PEER-COMMIT-ELEMENT)))
-	 * If K is identity element (one), reject.
-	 * k = F(K) (= x coordinate)
+	 * If esp_K is identity element (one), reject.
+	 * k = F(esp_K) (= x coordinate)
 	 */
 
 	if (crypto_bignum_exptmod(sae->tmp->pwe_ffc, sae->peer_commit_scalar,
-				  sae->tmp->prime, K) < 0 ||
-	    crypto_bignum_mulmod(K, sae->tmp->peer_commit_element_ffc,
-				 sae->tmp->prime, K) < 0 ||
-	    crypto_bignum_exptmod(K, sae->tmp->sae_rand, sae->tmp->prime, K) < 0
+				  sae->tmp->prime, esp_K) < 0 ||
+	    crypto_bignum_mulmod(esp_K, sae->tmp->peer_commit_element_ffc,
+				 sae->tmp->prime, esp_K) < 0 ||
+	    crypto_bignum_exptmod(esp_K, sae->tmp->sae_rand, sae->tmp->prime, esp_K) < 0
 	    ||
-	    crypto_bignum_is_one(K) ||
-	    crypto_bignum_to_bin(K, k, SAE_MAX_PRIME_LEN, sae->tmp->prime_len) <
+	    crypto_bignum_is_one(esp_K) ||
+	    crypto_bignum_to_bin(esp_K, k, SAE_MAX_PRIME_LEN, sae->tmp->prime_len) <
 	    0) {
-		wpa_printf(MSG_DEBUG, "SAE: Failed to calculate K and k");
+		wpa_printf(MSG_DEBUG, "SAE: Failed to calculate esp_K and k");
 		goto fail;
 	}
 
@@ -1488,7 +1488,7 @@ static int sae_derive_k_ffc(struct sae_data *sae, u8 *k)
 
 	ret = 0;
 fail:
-	crypto_bignum_deinit(K, 1);
+	crypto_bignum_deinit(esp_K, 1);
 	return ret;
 }
 
diff --git a/components/wpa_supplicant/src/common/wpa_common.c b/components/wpa_supplicant/src/common/wpa_common.c
index 4cdf7ab38805a1cee706ffde250c30a86ad8debe..d799463be71e4098674fb8fdf28024244ca44a64 100644
--- a/components/wpa_supplicant/src/common/wpa_common.c
+++ b/components/wpa_supplicant/src/common/wpa_common.c
@@ -849,7 +849,7 @@ int wpa_pmk_r1_to_ptk(const u8 *pmk_r1, const u8 *snonce, const u8 *anonce,
 /**
  * wpa_eapol_key_mic - Calculate EAPOL-Key MIC
  * @key: EAPOL-Key Key Confirmation Key (KCK)
- * @key_len: KCK length in octets
+ * @esp_key_len: KCK length in octets
  * @akmp: WPA_KEY_MGMT_* used in key derivation
  * @ver: Key descriptor version (WPA_KEY_INFO_TYPE_*)
  * @buf: Pointer to the beginning of the EAPOL header (version field)
@@ -866,16 +866,16 @@ int wpa_pmk_r1_to_ptk(const u8 *pmk_r1, const u8 *snonce, const u8 *anonce,
  * happened during final editing of the standard and the correct behavior is
  * defined in the last draft (IEEE 802.11i/D10).
  */
-int wpa_eapol_key_mic(const u8 *key, size_t key_len, int akmp, int ver,
+int wpa_eapol_key_mic(const u8 *key, size_t esp_key_len, int akmp, int ver,
 		      const u8 *buf, size_t len, u8 *mic)
 {
 	u8 hash[SHA384_MAC_LEN];
 
 	switch (ver) {
 	case WPA_KEY_INFO_TYPE_HMAC_MD5_RC4:
-		return hmac_md5(key, key_len, buf, len, mic);
+		return hmac_md5(key, esp_key_len, buf, len, mic);
 	case WPA_KEY_INFO_TYPE_HMAC_SHA1_AES:
-		if (hmac_sha1(key, key_len, buf, len, hash))
+		if (hmac_sha1(key, esp_key_len, buf, len, hash))
 			return -1;
 		os_memcpy(mic, hash, MD5_MAC_LEN);
 		break;
@@ -890,14 +890,14 @@ int wpa_eapol_key_mic(const u8 *key, size_t key_len, int akmp, int ver,
 #endif /* CONFIG_WPA3_SAE */
 #ifdef CONFIG_SUITEB
 		case WPA_KEY_MGMT_IEEE8021X_SUITE_B:
-			if (hmac_sha256(key, key_len, buf, len, hash))
+			if (hmac_sha256(key, esp_key_len, buf, len, hash))
 				return -1;
 			os_memcpy(mic, hash, MD5_MAC_LEN);
 			break;
 #endif /* CONFIG_SUITEB */
 #ifdef CONFIG_SUITEB192
 		case WPA_KEY_MGMT_IEEE8021X_SUITE_B_192:
-			if (hmac_sha384(key, key_len, buf, len, hash))
+			if (hmac_sha384(key, esp_key_len, buf, len, hash))
 				return -1;
 			os_memcpy(mic, hash, 24);
 			break;
@@ -906,16 +906,16 @@ int wpa_eapol_key_mic(const u8 *key, size_t key_len, int akmp, int ver,
 		case WPA_KEY_MGMT_OWE:
 			wpa_printf(MSG_DEBUG,
 			"WPA: EAPOL-Key MIC using HMAC-SHA%u (AKM-defined - OWE)",
-			(unsigned int) key_len * 8 * 2);
-			if (key_len == 128 / 8) {
-				if (hmac_sha256(key, key_len, buf, len, hash))
+			(unsigned int) esp_key_len * 8 * 2);
+			if (esp_key_len == 128 / 8) {
+				if (hmac_sha256(key, esp_key_len, buf, len, hash))
 					return -1;
 			} else {
 				wpa_printf(MSG_INFO,"OWE: Unsupported KCK length: %u",
-				(unsigned int) key_len);
+				(unsigned int) esp_key_len);
 				return -1;
                         }
-                        os_memcpy(mic, hash, key_len);
+                        os_memcpy(mic, hash, esp_key_len);
                         break;
 
 #endif /* CONFIG_OWE_STA */
diff --git a/components/wpa_supplicant/src/common/wpa_common.h b/components/wpa_supplicant/src/common/wpa_common.h
index 043f4bdc046bf2724c34be9ea60182166423c2eb..40f25b0323e18ab607e71ba1b2d015f9cf0542b7 100644
--- a/components/wpa_supplicant/src/common/wpa_common.h
+++ b/components/wpa_supplicant/src/common/wpa_common.h
@@ -422,7 +422,7 @@ struct wpa_ft_ies {
 
 int wpa_ft_parse_ies(const u8 *ies, size_t ies_len, struct wpa_ft_ies *parse);
 
-int wpa_eapol_key_mic(const u8 *key, size_t key_len, int akmp, int ver,
+int wpa_eapol_key_mic(const u8 *key, size_t esp_key_len, int akmp, int ver,
 		      const u8 *buf, size_t len, u8 *mic);
 int wpa_pmk_to_ptk(const u8 *pmk, size_t pmk_len, const char *label,
 		   const u8 *addr1, const u8 *addr2,
diff --git a/components/wpa_supplicant/src/common/wpa_supplicant_i.h b/components/wpa_supplicant/src/common/wpa_supplicant_i.h
index 77907842fb61f4afabb6f9c3d649852063c27c04..c8179eb76855da4f68e83c215df73fa9dab17604 100644
--- a/components/wpa_supplicant/src/common/wpa_supplicant_i.h
+++ b/components/wpa_supplicant/src/common/wpa_supplicant_i.h
@@ -13,7 +13,7 @@
 #include "drivers/driver.h"
 #include "common/ieee802_11_defs.h"
 /*
- * struct rrm_data - Data used for managing RRM features
+ * struct rrm_data - Data used for managing RRM esp_features
  */
 struct rrm_data {
 	/* rrm_used - indication regarding the current connection */
diff --git a/components/wpa_supplicant/src/crypto/aes-ccm.c b/components/wpa_supplicant/src/crypto/aes-ccm.c
index e5bb94ca0868a9e83c7880b8b95cadf11a40441f..507c8f5458e4015bf11114456c12f2007522a2aa 100644
--- a/components/wpa_supplicant/src/crypto/aes-ccm.c
+++ b/components/wpa_supplicant/src/crypto/aes-ccm.c
@@ -42,7 +42,7 @@ static void aes_ccm_auth_start(void *aes, size_t M, size_t L, const u8 *nonce,
 	WPA_PUT_BE16(&b[AES_BLOCK_SIZE - L], plain_len);
 
 	wpa_hexdump_key(MSG_DEBUG, "CCM B_0", b, AES_BLOCK_SIZE);
-	aes_encrypt(aes, b, x); /* X_1 = E(K, B_0) */
+	aes_encrypt(aes, b, x); /* X_1 = E(esp_K, B_0) */
 
 	if (!aad_len)
 		return;
@@ -52,11 +52,11 @@ static void aes_ccm_auth_start(void *aes, size_t M, size_t L, const u8 *nonce,
 	os_memset(aad_buf + 2 + aad_len, 0, sizeof(aad_buf) - 2 - aad_len);
 
 	xor_aes_block(aad_buf, x);
-	aes_encrypt(aes, aad_buf, x); /* X_2 = E(K, X_1 XOR B_1) */
+	aes_encrypt(aes, aad_buf, x); /* X_2 = E(esp_K, X_1 XOR B_1) */
 
 	if (aad_len > AES_BLOCK_SIZE - 2) {
 		xor_aes_block(&aad_buf[AES_BLOCK_SIZE], x);
-		/* X_3 = E(K, X_2 XOR B_2) */
+		/* X_3 = E(esp_K, X_2 XOR B_2) */
 		aes_encrypt(aes, &aad_buf[AES_BLOCK_SIZE], x);
 	}
 }
@@ -68,7 +68,7 @@ static void aes_ccm_auth(void *aes, const u8 *data, size_t len, u8 *x)
 	size_t i;
 
 	for (i = 0; i < len / AES_BLOCK_SIZE; i++) {
-		/* X_i+1 = E(K, X_i XOR B_i) */
+		/* X_i+1 = E(esp_K, X_i XOR B_i) */
 		xor_aes_block(x, data);
 		data += AES_BLOCK_SIZE;
 		aes_encrypt(aes, x, x);
@@ -99,7 +99,7 @@ static void aes_ccm_encr(void *aes, size_t L, const u8 *in, size_t len, u8 *out,
 	/* crypt = msg XOR (S_1 | S_2 | ... | S_n) */
 	for (i = 1; i <= len / AES_BLOCK_SIZE; i++) {
 		WPA_PUT_BE16(&a[AES_BLOCK_SIZE - 2], i);
-		/* S_i = E(K, A_i) */
+		/* S_i = E(esp_K, A_i) */
 		aes_encrypt(aes, a, out);
 		xor_aes_block(out, in);
 		out += AES_BLOCK_SIZE;
@@ -121,7 +121,7 @@ static void aes_ccm_encr_auth(void *aes, size_t M, u8 *x, u8 *a, u8 *auth)
 	u8 tmp[AES_BLOCK_SIZE];
 
 	wpa_hexdump_key(MSG_DEBUG, "CCM T", x, M);
-	/* U = T XOR S_0; S_0 = E(K, A_0) */
+	/* U = T XOR S_0; S_0 = E(esp_K, A_0) */
 	WPA_PUT_BE16(&a[AES_BLOCK_SIZE - 2], 0);
 	aes_encrypt(aes, a, tmp);
 	for (i = 0; i < M; i++)
@@ -136,7 +136,7 @@ static void aes_ccm_decr_auth(void *aes, size_t M, u8 *a, const u8 *auth, u8 *t)
 	u8 tmp[AES_BLOCK_SIZE];
 
 	wpa_hexdump_key(MSG_DEBUG, "CCM U", auth, M);
-	/* U = T XOR S_0; S_0 = E(K, A_0) */
+	/* U = T XOR S_0; S_0 = E(esp_K, A_0) */
 	WPA_PUT_BE16(&a[AES_BLOCK_SIZE - 2], 0);
 	aes_encrypt(aes, a, tmp);
 	for (i = 0; i < M; i++)
@@ -146,7 +146,7 @@ static void aes_ccm_decr_auth(void *aes, size_t M, u8 *a, const u8 *auth, u8 *t)
 
 
 /* AES-CCM with fixed L=2 and aad_len <= 30 assumption */
-int aes_ccm_ae(const u8 *key, size_t key_len, const u8 *nonce,
+int aes_ccm_ae(const u8 *key, size_t esp_key_len, const u8 *nonce,
 	       size_t M, const u8 *plain, size_t plain_len,
 	       const u8 *aad, size_t aad_len, u8 *crypt, u8 *auth)
 {
@@ -157,7 +157,7 @@ int aes_ccm_ae(const u8 *key, size_t key_len, const u8 *nonce,
 	if (aad_len > 30 || M > AES_BLOCK_SIZE)
 		return -1;
 
-	aes = aes_encrypt_init(key, key_len);
+	aes = aes_encrypt_init(key, esp_key_len);
 	if (aes == NULL)
 		return -1;
 
@@ -176,7 +176,7 @@ int aes_ccm_ae(const u8 *key, size_t key_len, const u8 *nonce,
 
 
 /* AES-CCM with fixed L=2 and aad_len <= 30 assumption */
-int aes_ccm_ad(const u8 *key, size_t key_len, const u8 *nonce,
+int aes_ccm_ad(const u8 *key, size_t esp_key_len, const u8 *nonce,
 	       size_t M, const u8 *crypt, size_t crypt_len,
 	       const u8 *aad, size_t aad_len, const u8 *auth, u8 *plain)
 {
@@ -188,7 +188,7 @@ int aes_ccm_ad(const u8 *key, size_t key_len, const u8 *nonce,
 	if (aad_len > 30 || M > AES_BLOCK_SIZE)
 		return -1;
 
-	aes = aes_encrypt_init(key, key_len);
+	aes = aes_encrypt_init(key, esp_key_len);
 	if (aes == NULL)
 		return -1;
 
diff --git a/components/wpa_supplicant/src/crypto/aes-ctr.c b/components/wpa_supplicant/src/crypto/aes-ctr.c
index 8ce05b894db6d1ecedb7329940222b3897d82fcb..9e936ddb56d08f56a07ac8ec1c484a51bd7cc7c8 100644
--- a/components/wpa_supplicant/src/crypto/aes-ctr.c
+++ b/components/wpa_supplicant/src/crypto/aes-ctr.c
@@ -15,14 +15,14 @@
 
 /**
  * aes_ctr_encrypt - AES-128/192/256 CTR mode encryption
- * @key: Key for encryption (key_len bytes)
- * @key_len: Length of the key (16, 24, or 32 bytes)
+ * @key: Key for encryption (esp_key_len bytes)
+ * @esp_key_len: Length of the key (16, 24, or 32 bytes)
  * @nonce: Nonce for counter mode (16 bytes)
  * @data: Data to encrypt in-place
  * @data_len: Length of data in bytes
  * Returns: 0 on success, Negative value on failure
  */
-int aes_ctr_encrypt(const u8 *key, size_t key_len, const u8 *nonce,
+int aes_ctr_encrypt(const u8 *key, size_t esp_key_len, const u8 *nonce,
 		    u8 *data, size_t data_len)
 {
 	void *ctx;
@@ -31,7 +31,7 @@ int aes_ctr_encrypt(const u8 *key, size_t key_len, const u8 *nonce,
 	u8 *pos = data;
 	u8 counter[AES_BLOCK_SIZE], buf[AES_BLOCK_SIZE];
 
-	ctx = aes_encrypt_init(key, key_len);
+	ctx = aes_encrypt_init(key, esp_key_len);
 	if (ctx == NULL)
 		return -1;
 	os_memcpy(counter, nonce, AES_BLOCK_SIZE);
@@ -58,7 +58,7 @@ int aes_ctr_encrypt(const u8 *key, size_t key_len, const u8 *nonce,
 
 /**
  * aes_128_ctr_encrypt - AES-128 CTR mode encryption
- * @key: Key for encryption (key_len bytes)
+ * @key: Key for encryption (esp_key_len bytes)
  * @nonce: Nonce for counter mode (16 bytes)
  * @data: Data to encrypt in-place
  * @data_len: Length of data in bytes
diff --git a/components/wpa_supplicant/src/crypto/aes-gcm.c b/components/wpa_supplicant/src/crypto/aes-gcm.c
index 84294d2d104caae7268d91e98ab6836ac3d68cfb..0a937f5e6bb44e841eb4f3cce8f89ac437587e74 100644
--- a/components/wpa_supplicant/src/crypto/aes-gcm.c
+++ b/components/wpa_supplicant/src/crypto/aes-gcm.c
@@ -172,11 +172,11 @@ static void aes_gctr(void *aes, const u8 *icb, const u8 *x, size_t xlen, u8 *y)
 }
 
 
-static void * aes_gcm_init_hash_subkey(const u8 *key, size_t key_len, u8 *H)
+static void * aes_gcm_init_hash_subkey(const u8 *key, size_t esp_key_len, u8 *H)
 {
 	void *aes;
 
-	aes = aes_encrypt_init(key, key_len);
+	aes = aes_encrypt_init(key, esp_key_len);
 	if (aes == NULL)
 		return NULL;
 
@@ -251,7 +251,7 @@ static void aes_gcm_ghash(const u8 *H, const u8 *aad, size_t aad_len,
 /**
  * aes_gcm_ae - GCM-AE_K(IV, P, A)
  */
-int aes_gcm_ae(const u8 *key, size_t key_len, const u8 *iv, size_t iv_len,
+int aes_gcm_ae(const u8 *key, size_t esp_key_len, const u8 *iv, size_t iv_len,
 	       const u8 *plain, size_t plain_len,
 	       const u8 *aad, size_t aad_len, u8 *crypt, u8 *tag)
 {
@@ -260,7 +260,7 @@ int aes_gcm_ae(const u8 *key, size_t key_len, const u8 *iv, size_t iv_len,
 	u8 S[16];
 	void *aes;
 
-	aes = aes_gcm_init_hash_subkey(key, key_len, H);
+	aes = aes_gcm_init_hash_subkey(key, esp_key_len, H);
 	if (aes == NULL)
 		return -1;
 
@@ -285,7 +285,7 @@ int aes_gcm_ae(const u8 *key, size_t key_len, const u8 *iv, size_t iv_len,
 /**
  * aes_gcm_ad - GCM-AD_K(IV, C, A, T)
  */
-int aes_gcm_ad(const u8 *key, size_t key_len, const u8 *iv, size_t iv_len,
+int aes_gcm_ad(const u8 *key, size_t esp_key_len, const u8 *iv, size_t iv_len,
 	       const u8 *crypt, size_t crypt_len,
 	       const u8 *aad, size_t aad_len, const u8 *tag, u8 *plain)
 {
@@ -294,7 +294,7 @@ int aes_gcm_ad(const u8 *key, size_t key_len, const u8 *iv, size_t iv_len,
 	u8 S[16], T[16];
 	void *aes;
 
-	aes = aes_gcm_init_hash_subkey(key, key_len, H);
+	aes = aes_gcm_init_hash_subkey(key, esp_key_len, H);
 	if (aes == NULL)
 		return -1;
 
@@ -319,9 +319,9 @@ int aes_gcm_ad(const u8 *key, size_t key_len, const u8 *iv, size_t iv_len,
 }
 
 
-int aes_gmac(const u8 *key, size_t key_len, const u8 *iv, size_t iv_len,
+int aes_gmac(const u8 *key, size_t esp_key_len, const u8 *iv, size_t iv_len,
 	     const u8 *aad, size_t aad_len, u8 *tag)
 {
-	return aes_gcm_ae(key, key_len, iv, iv_len, NULL, 0, aad, aad_len, NULL,
+	return aes_gcm_ae(key, esp_key_len, iv, iv_len, NULL, 0, aad, aad_len, NULL,
 			  tag);
 }
diff --git a/components/wpa_supplicant/src/crypto/aes-internal.c b/components/wpa_supplicant/src/crypto/aes-internal.c
index bd4535d2096e21ae6f1d3fce290728ca215924f0..c400015b1ef4d89f65987f84746e23fa61836ac5 100644
--- a/components/wpa_supplicant/src/crypto/aes-internal.c
+++ b/components/wpa_supplicant/src/crypto/aes-internal.c
@@ -790,7 +790,7 @@ int rijndaelKeySetupEnc(u32 rk[], const u8 cipherKey[], int keyBits)
 		for (i = 0; i < 10; i++) {
 			temp  = rk[3];
 			rk[4] = rk[0] ^ TE421(temp) ^ TE432(temp) ^
-				TE443(temp) ^ TE414(temp) ^ RCON(i);
+				TE443(temp) ^ TE414(temp) ^ esp_RCON(i);
 			rk[5] = rk[1] ^ rk[4];
 			rk[6] = rk[2] ^ rk[5];
 			rk[7] = rk[3] ^ rk[6];
@@ -806,7 +806,7 @@ int rijndaelKeySetupEnc(u32 rk[], const u8 cipherKey[], int keyBits)
 		for (i = 0; i < 8; i++) {
 			temp  = rk[5];
 			rk[6] = rk[0] ^ TE421(temp) ^ TE432(temp) ^
-				TE443(temp) ^ TE414(temp) ^ RCON(i);
+				TE443(temp) ^ TE414(temp) ^ esp_RCON(i);
 			rk[7] = rk[1] ^ rk[6];
 			rk[8] = rk[2] ^ rk[7];
 			rk[9] = rk[3] ^ rk[8];
@@ -825,7 +825,7 @@ int rijndaelKeySetupEnc(u32 rk[], const u8 cipherKey[], int keyBits)
 		for (i = 0; i < 7; i++) {
 			temp  = rk[7];
 			rk[8] = rk[0] ^ TE421(temp) ^ TE432(temp) ^
-				TE443(temp) ^ TE414(temp) ^ RCON(i);
+				TE443(temp) ^ TE414(temp) ^ esp_RCON(i);
 			rk[9] = rk[1] ^ rk[8];
 			rk[10] = rk[2] ^ rk[9];
 			rk[11] = rk[3] ^ rk[10];
diff --git a/components/wpa_supplicant/src/crypto/aes-omac1.c b/components/wpa_supplicant/src/crypto/aes-omac1.c
index 8642516340c69e2ad0e93757b7b679d21e0c695b..0a3420492ecf1697a3a3cb4321b97d789246c65a 100644
--- a/components/wpa_supplicant/src/crypto/aes-omac1.c
+++ b/components/wpa_supplicant/src/crypto/aes-omac1.c
@@ -29,7 +29,7 @@ static void gf_mulx(u8 *pad)
 /**
  * omac1_aes_vector - One-Key CBC MAC (OMAC1) hash with AES
  * @key: Key for the hash operation
- * @key_len: Key length in octets
+ * @esp_key_len: Key length in octets
  * @num_elem: Number of elements in the data vector
  * @addr: Pointers to the data areas
  * @len: Lengths of the data blocks
@@ -40,7 +40,7 @@ static void gf_mulx(u8 *pad)
  * OMAC1 was standardized with the name CMAC by NIST in a Special Publication
  * (SP) 800-38B.
  */
-int omac1_aes_vector(const u8 *key, size_t key_len, size_t num_elem,
+int omac1_aes_vector(const u8 *key, size_t esp_key_len, size_t num_elem,
 		     const u8 *addr[], const size_t *len, u8 *mac)
 {
 	void *ctx;
@@ -51,7 +51,7 @@ int omac1_aes_vector(const u8 *key, size_t key_len, size_t num_elem,
 	if (TEST_FAIL())
 		return -1;
 
-	ctx = aes_encrypt_init(key, key_len);
+	ctx = aes_encrypt_init(key, esp_key_len);
 	if (ctx == NULL)
 		return -1;
 	os_memset(cbc, 0, AES_BLOCK_SIZE);
diff --git a/components/wpa_supplicant/src/crypto/aes-siv.c b/components/wpa_supplicant/src/crypto/aes-siv.c
index b8b152f7ca31db65ef59cb6e1688fbe55406e662..99b432338a5512513da0cdcceac161b450caf189 100644
--- a/components/wpa_supplicant/src/crypto/aes-siv.c
+++ b/components/wpa_supplicant/src/crypto/aes-siv.c
@@ -61,7 +61,7 @@ static void pad_block(u8 *pad, const u8 *addr, size_t len)
 }
 
 
-static int aes_s2v(const u8 *key, size_t key_len,
+static int aes_s2v(const u8 *key, size_t esp_key_len,
 		   size_t num_elem, const u8 *addr[], size_t *len, u8 *mac)
 {
 	u8 tmp[AES_BLOCK_SIZE], tmp2[AES_BLOCK_SIZE];
@@ -76,17 +76,17 @@ static int aes_s2v(const u8 *key, size_t key_len,
 		tmp[AES_BLOCK_SIZE - 1] = 1;
 		data[0] = tmp;
 		data_len[0] = sizeof(tmp);
-		return omac1_aes_vector(key, key_len, 1, data, data_len, mac);
+		return omac1_aes_vector(key, esp_key_len, 1, data, data_len, mac);
 	}
 
 	data[0] = zero;
 	data_len[0] = sizeof(zero);
-	ret = omac1_aes_vector(key, key_len, 1, data, data_len, tmp);
+	ret = omac1_aes_vector(key, esp_key_len, 1, data, data_len, tmp);
 	if (ret)
 		return ret;
 
 	for (i = 0; i < num_elem - 1; i++) {
-		ret = omac1_aes_vector(key, key_len, 1, &addr[i], &len[i],
+		ret = omac1_aes_vector(key, esp_key_len, 1, &addr[i], &len[i],
 				       tmp2);
 		if (ret)
 			return ret;
@@ -101,7 +101,7 @@ static int aes_s2v(const u8 *key, size_t key_len,
 
 		xorend(buf, len[i], tmp, AES_BLOCK_SIZE);
 		data[0] = buf;
-		ret = omac1_aes_vector(key, key_len, 1, data, &len[i], mac);
+		ret = omac1_aes_vector(key, esp_key_len, 1, data, &len[i], mac);
 		bin_clear_free(buf, len[i]);
 		return ret;
 	}
@@ -112,11 +112,11 @@ static int aes_s2v(const u8 *key, size_t key_len,
 
 	data[0] = tmp;
 	data_len[0] = sizeof(tmp);
-	return omac1_aes_vector(key, key_len, 1, data, data_len, mac);
+	return omac1_aes_vector(key, esp_key_len, 1, data, data_len, mac);
 }
 
 
-int aes_siv_encrypt(const u8 *key, size_t key_len,
+int aes_siv_encrypt(const u8 *key, size_t esp_key_len,
 		    const u8 *pw, size_t pwlen,
 		    size_t num_elem, const u8 *addr[], const size_t *len,
 		    u8 *out)
@@ -129,12 +129,12 @@ int aes_siv_encrypt(const u8 *key, size_t key_len,
 	u8 *iv, *crypt_pw;
 
 	if (num_elem > ARRAY_SIZE(_addr) - 1 ||
-	    (key_len != 32 && key_len != 48 && key_len != 64))
+	    (esp_key_len != 32 && esp_key_len != 48 && esp_key_len != 64))
 		return -1;
 
-	key_len /= 2;
+	esp_key_len /= 2;
 	k1 = key;
-	k2 = key + key_len;
+	k2 = key + esp_key_len;
 
 	for (i = 0; i < num_elem; i++) {
 		_addr[i] = addr[i];
@@ -143,7 +143,7 @@ int aes_siv_encrypt(const u8 *key, size_t key_len,
 	_addr[num_elem] = pw;
 	_len[num_elem] = pwlen;
 
-	if (aes_s2v(k1, key_len, num_elem + 1, _addr, _len, v))
+	if (aes_s2v(k1, esp_key_len, num_elem + 1, _addr, _len, v))
 		return -1;
 
 	iv = out;
@@ -155,11 +155,11 @@ int aes_siv_encrypt(const u8 *key, size_t key_len,
 	/* zero out 63rd and 31st bits of ctr (from right) */
 	v[8] &= 0x7f;
 	v[12] &= 0x7f;
-	return aes_ctr_encrypt(k2, key_len, v, crypt_pw, pwlen);
+	return aes_ctr_encrypt(k2, esp_key_len, v, crypt_pw, pwlen);
 }
 
 
-int aes_siv_decrypt(const u8 *key, size_t key_len,
+int aes_siv_decrypt(const u8 *key, size_t esp_key_len,
 		    const u8 *iv_crypt, size_t iv_c_len,
 		    size_t num_elem, const u8 *addr[], const size_t *len,
 		    u8 *out)
@@ -174,12 +174,12 @@ int aes_siv_decrypt(const u8 *key, size_t key_len,
 	u8 check[AES_BLOCK_SIZE];
 
 	if (iv_c_len < AES_BLOCK_SIZE || num_elem > ARRAY_SIZE(_addr) - 1 ||
-	    (key_len != 32 && key_len != 48 && key_len != 64))
+	    (esp_key_len != 32 && esp_key_len != 48 && esp_key_len != 64))
 		return -1;
 	crypt_len = iv_c_len - AES_BLOCK_SIZE;
-	key_len /= 2;
+	esp_key_len /= 2;
 	k1 = key;
-	k2 = key + key_len;
+	k2 = key + esp_key_len;
 
 	for (i = 0; i < num_elem; i++) {
 		_addr[i] = addr[i];
@@ -194,11 +194,11 @@ int aes_siv_decrypt(const u8 *key, size_t key_len,
 	iv[8] &= 0x7f;
 	iv[12] &= 0x7f;
 
-	ret = aes_ctr_encrypt(k2, key_len, iv, out, crypt_len);
+	ret = aes_ctr_encrypt(k2, esp_key_len, iv, out, crypt_len);
 	if (ret)
 		return ret;
 
-	ret = aes_s2v(k1, key_len, num_elem + 1, _addr, _len, check);
+	ret = aes_s2v(k1, esp_key_len, num_elem + 1, _addr, _len, check);
 	if (ret)
 		return ret;
 	if (os_memcmp(check, iv_crypt, AES_BLOCK_SIZE) == 0)
diff --git a/components/wpa_supplicant/src/crypto/aes-unwrap.c b/components/wpa_supplicant/src/crypto/aes-unwrap.c
index ec793d9dbf78b74a96579efcf73d83397bfcfdba..b3cb0e5c9a038047d636c659e28a5fa401251b0e 100644
--- a/components/wpa_supplicant/src/crypto/aes-unwrap.c
+++ b/components/wpa_supplicant/src/crypto/aes-unwrap.c
@@ -1,5 +1,5 @@
 /*
- * AES key unwrap (RFC3394)
+ * AES key esp_unwrap (RFC3394)
  *
  * Copyright (c) 2003-2007, Jouni Malinen <j@w1.fi>
  *
@@ -43,7 +43,7 @@ int aes_unwrap(const u8 *kek, size_t kek_len, int n, const u8 *cipher,
 	/* 2) Compute intermediate values.
 	 * For j = 5 to 0
 	 *     For i = n to 1
-	 *         B = AES-1(K, (A ^ t) | R[i]) where t = n*j+i
+	 *         B = AES-1(esp_K, (A ^ t) | R[i]) where t = n*j+i
 	 *         A = MSB(64, B)
 	 *         R[i] = LSB(64, B)
 	 */
diff --git a/components/wpa_supplicant/src/crypto/aes-wrap.c b/components/wpa_supplicant/src/crypto/aes-wrap.c
index 7ed34e803e4e53383793d3f4278b033636090f6d..2c6be608f2b5721147aa279d42b2742dc2c8105c 100644
--- a/components/wpa_supplicant/src/crypto/aes-wrap.c
+++ b/components/wpa_supplicant/src/crypto/aes-wrap.c
@@ -44,7 +44,7 @@ int aes_wrap(const u8 *kek, size_t kek_len, int n, const u8 *plain, u8 *cipher)
 	/* 2) Calculate intermediate values.
 	 * For j = 0 to 5
 	 *     For i=1 to n
-	 *         B = AES(K, A | R[i])
+	 *         B = AES(esp_K, A | R[i])
 	 *         A = MSB(64, B) ^ t where t = (n*j)+i
 	 *         R[i] = LSB(64, B)
 	 */
diff --git a/components/wpa_supplicant/src/crypto/aes_i.h b/components/wpa_supplicant/src/crypto/aes_i.h
index b20ec92203ade84b21b01139c3d14798b22f374d..4d570ee4e85ca52f3906ad049dee87306eb638f5 100644
--- a/components/wpa_supplicant/src/crypto/aes_i.h
+++ b/components/wpa_supplicant/src/crypto/aes_i.h
@@ -30,7 +30,7 @@ extern const u8 rcons[10];
 
 #ifndef AES_SMALL_TABLES
 
-#define RCON(i) rcon[(i)]
+#define esp_RCON(i) rcon[(i)]
 
 #define TE0(i) Te0[((i) >> 24) & 0xff]
 #define TE1(i) Te1[((i) >> 16) & 0xff]
@@ -65,7 +65,7 @@ extern const u8 rcons[10];
 
 #else /* AES_SMALL_TABLES */
 
-#define RCON(i) ((u32) rcons[(i)] << 24)
+#define esp_RCON(i) ((u32) rcons[(i)] << 24)
 
 static inline u32 rotr(u32 val, int bits)
 {
diff --git a/components/wpa_supplicant/src/crypto/aes_siv.h b/components/wpa_supplicant/src/crypto/aes_siv.h
index fb05d80c1f12f68be46dd4125ec46f463a52d13b..2db563a02551dba889979867b4dbca1258de17cd 100644
--- a/components/wpa_supplicant/src/crypto/aes_siv.h
+++ b/components/wpa_supplicant/src/crypto/aes_siv.h
@@ -9,11 +9,11 @@
 #ifndef AES_SIV_H
 #define AES_SIV_H
 
-int aes_siv_encrypt(const u8 *key, size_t key_len,
+int aes_siv_encrypt(const u8 *key, size_t esp_key_len,
 		    const u8 *pw, size_t pwlen,
 		    size_t num_elem, const u8 *addr[], const size_t *len,
 		    u8 *out);
-int aes_siv_decrypt(const u8 *key, size_t key_len,
+int aes_siv_decrypt(const u8 *key, size_t esp_key_len,
 		    const u8 *iv_crypt, size_t iv_c_len,
 		    size_t num_elem, const u8 *addr[], const size_t *len,
 		    u8 *out);
diff --git a/components/wpa_supplicant/src/crypto/aes_wrap.h b/components/wpa_supplicant/src/crypto/aes_wrap.h
index b70b1d26e550380e97156891df96ce12f8081714..3068448cdcb7d324b5d9e1b7f30572f717d7d7e3 100644
--- a/components/wpa_supplicant/src/crypto/aes_wrap.h
+++ b/components/wpa_supplicant/src/crypto/aes_wrap.h
@@ -22,7 +22,7 @@ int __must_check aes_wrap(const u8 *kek, size_t kek_len, int n, const u8 *plain,
 			  u8 *cipher);
 int __must_check aes_unwrap(const u8 *kek, size_t kek_len, int n,
 			    const u8 *cipher, u8 *plain);
-int __must_check omac1_aes_vector(const u8 *key, size_t key_len,
+int __must_check omac1_aes_vector(const u8 *key, size_t esp_key_len,
 				  size_t num_elem, const u8 *addr[],
 				  const size_t *len, u8 *mac);
 int __must_check omac1_aes_128_vector(const u8 *key, size_t num_elem,
@@ -33,7 +33,7 @@ int __must_check omac1_aes_128(const u8 *key, const u8 *data, size_t data_len,
 int __must_check omac1_aes_256(const u8 *key, const u8 *data, size_t data_len,
 			       u8 *mac);
 int __must_check aes_128_encrypt_block(const u8 *key, const u8 *in, u8 *out);
-int __must_check aes_ctr_encrypt(const u8 *key, size_t key_len, const u8 *nonce,
+int __must_check aes_ctr_encrypt(const u8 *key, size_t esp_key_len, const u8 *nonce,
 				 u8 *data, size_t data_len);
 int __must_check aes_128_ctr_encrypt(const u8 *key, const u8 *nonce,
 				     u8 *data, size_t data_len);
@@ -49,23 +49,23 @@ int __must_check aes_128_cbc_encrypt(const u8 *key, const u8 *iv, u8 *data,
 				     size_t data_len);
 int __must_check aes_128_cbc_decrypt(const u8 *key, const u8 *iv, u8 *data,
 				     size_t data_len);
-int __must_check aes_gcm_ae(const u8 *key, size_t key_len,
+int __must_check aes_gcm_ae(const u8 *key, size_t esp_key_len,
 			    const u8 *iv, size_t iv_len,
 			    const u8 *plain, size_t plain_len,
 			    const u8 *aad, size_t aad_len,
 			    u8 *crypt, u8 *tag);
-int __must_check aes_gcm_ad(const u8 *key, size_t key_len,
+int __must_check aes_gcm_ad(const u8 *key, size_t esp_key_len,
 			    const u8 *iv, size_t iv_len,
 			    const u8 *crypt, size_t crypt_len,
 			    const u8 *aad, size_t aad_len, const u8 *tag,
 			    u8 *plain);
-int __must_check aes_gmac(const u8 *key, size_t key_len,
+int __must_check aes_gmac(const u8 *key, size_t esp_key_len,
 			  const u8 *iv, size_t iv_len,
 			  const u8 *aad, size_t aad_len, u8 *tag);
-int __must_check aes_ccm_ae(const u8 *key, size_t key_len, const u8 *nonce,
+int __must_check aes_ccm_ae(const u8 *key, size_t esp_key_len, const u8 *nonce,
 			    size_t M, const u8 *plain, size_t plain_len,
 			    const u8 *aad, size_t aad_len, u8 *crypt, u8 *auth);
-int __must_check aes_ccm_ad(const u8 *key, size_t key_len, const u8 *nonce,
+int __must_check aes_ccm_ad(const u8 *key, size_t esp_key_len, const u8 *nonce,
 			    size_t M, const u8 *crypt, size_t crypt_len,
 			    const u8 *aad, size_t aad_len, const u8 *auth,
 			    u8 *plain);
diff --git a/components/wpa_supplicant/src/crypto/crypto.h b/components/wpa_supplicant/src/crypto/crypto.h
index cae569284a35bf3a0cac4c49d3c8d0b132c81fcd..0afaf3fb4884962d6c68c058ecba8fc47d400f0c 100644
--- a/components/wpa_supplicant/src/crypto/crypto.h
+++ b/components/wpa_supplicant/src/crypto/crypto.h
@@ -171,7 +171,7 @@ struct crypto_hash;
  * crypto_hash_init - Initialize hash/HMAC function
  * @alg: Hash algorithm
  * @key: Key for keyed hash (e.g., HMAC) or %NULL if not needed
- * @key_len: Length of the key in bytes
+ * @esp_key_len: Length of the key in bytes
  * Returns: Pointer to hash context to use with other hash functions or %NULL
  * on failure
  *
@@ -180,7 +180,7 @@ struct crypto_hash;
  * to implement this.
  */
 struct crypto_hash * crypto_hash_init(enum crypto_hash_alg alg, const u8 *key,
-				      size_t key_len);
+				      size_t esp_key_len);
 
 /**
  * crypto_hash_update - Add data to hash calculation
@@ -226,7 +226,7 @@ struct crypto_cipher;
  * @alg: Cipher algorithm
  * @iv: Initialization vector for block ciphers or %NULL for stream ciphers
  * @key: Cipher key
- * @key_len: Length of key in bytes
+ * @esp_key_len: Length of key in bytes
  * Returns: Pointer to cipher context to use with other cipher functions or
  * %NULL on failure
  *
@@ -236,7 +236,7 @@ struct crypto_cipher;
  */
 struct crypto_cipher * crypto_cipher_init(enum crypto_cipher_alg alg,
 					  const u8 *iv, const u8 *key,
-					  size_t key_len);
+					  size_t esp_key_len);
 
 /**
  * crypto_cipher_encrypt - Cipher encrypt
@@ -1121,10 +1121,10 @@ void crypto_free_buffer(unsigned char *buf);
  * @crypto_ec_get_priv_key_der: get private key in der format
  * @key: key structure
  * @key_data: key data in charater buffer
- * @key_len = key length of charater buffer
+ * @esp_key_len = key length of charater buffer
  * Return : 0 if success
  */
-int crypto_ec_get_priv_key_der(struct crypto_key *key, unsigned char **key_data, int *key_len);
+int crypto_ec_get_priv_key_der(struct crypto_key *key, unsigned char **key_data, int *esp_key_len);
 
 /**
  * crypto_bignum_to_string: get big number in ascii format
diff --git a/components/wpa_supplicant/src/crypto/crypto_internal-cipher.c b/components/wpa_supplicant/src/crypto/crypto_internal-cipher.c
index ad0930a5a9d36ceec17456205d3fcf1e76dfec51..1f9d5dfcd50bfd059909ed88edd6f10007deca42 100644
--- a/components/wpa_supplicant/src/crypto/crypto_internal-cipher.c
+++ b/components/wpa_supplicant/src/crypto/crypto_internal-cipher.c
@@ -42,7 +42,7 @@ struct crypto_cipher {
 
 struct crypto_cipher * crypto_cipher_init(enum crypto_cipher_alg alg,
 					  const u8 *iv, const u8 *key,
-					  size_t key_len)
+					  size_t esp_key_len)
 {
 	struct crypto_cipher *ctx;
 
@@ -54,20 +54,20 @@ struct crypto_cipher * crypto_cipher_init(enum crypto_cipher_alg alg,
 
 	switch (alg) {
 	case CRYPTO_CIPHER_ALG_RC4:
-		if (key_len > sizeof(ctx->u.rc4.key)) {
+		if (esp_key_len > sizeof(ctx->u.rc4.key)) {
 			os_free(ctx);
 			return NULL;
 		}
-		ctx->u.rc4.keylen = key_len;
-		os_memcpy(ctx->u.rc4.key, key, key_len);
+		ctx->u.rc4.keylen = esp_key_len;
+		os_memcpy(ctx->u.rc4.key, key, esp_key_len);
 		break;
 	case CRYPTO_CIPHER_ALG_AES:
-		ctx->u.aes.ctx_enc = aes_encrypt_init(key, key_len);
+		ctx->u.aes.ctx_enc = aes_encrypt_init(key, esp_key_len);
 		if (ctx->u.aes.ctx_enc == NULL) {
 			os_free(ctx);
 			return NULL;
 		}
-		ctx->u.aes.ctx_dec = aes_decrypt_init(key, key_len);
+		ctx->u.aes.ctx_dec = aes_decrypt_init(key, esp_key_len);
 		if (ctx->u.aes.ctx_dec == NULL) {
 			aes_encrypt_deinit(ctx->u.aes.ctx_enc);
 			os_free(ctx);
@@ -76,7 +76,7 @@ struct crypto_cipher * crypto_cipher_init(enum crypto_cipher_alg alg,
 		os_memcpy(ctx->u.aes.cbc, iv, AES_BLOCK_SIZE);
 		break;
 	case CRYPTO_CIPHER_ALG_3DES:
-		if (key_len != 24) {
+		if (esp_key_len != 24) {
 			os_free(ctx);
 			return NULL;
 		}
@@ -84,7 +84,7 @@ struct crypto_cipher * crypto_cipher_init(enum crypto_cipher_alg alg,
 		os_memcpy(ctx->u.des3.cbc, iv, 8);
 		break;
 	case CRYPTO_CIPHER_ALG_DES:
-		if (key_len != 8) {
+		if (esp_key_len != 8) {
 			os_free(ctx);
 			return NULL;
 		}
diff --git a/components/wpa_supplicant/src/crypto/crypto_internal.c b/components/wpa_supplicant/src/crypto/crypto_internal.c
index aad40af16e06e3cc9e7c1b53b2bacbabf1bb5412..6a46cfeaeaba009eba9e2dc660d8d93d44d38d61 100644
--- a/components/wpa_supplicant/src/crypto/crypto_internal.c
+++ b/components/wpa_supplicant/src/crypto/crypto_internal.c
@@ -32,12 +32,12 @@ struct crypto_hash {
 #endif /* CONFIG_INTERNAL_SHA512 */
 	} u;
 	u8 key[64];
-	size_t key_len;
+	size_t esp_key_len;
 };
 
 
 struct crypto_hash * crypto_hash_init(enum crypto_hash_alg alg, const u8 *key,
-				      size_t key_len)
+				      size_t esp_key_len)
 {
 	struct crypto_hash *ctx;
 	u8 k_pad[64];
@@ -73,38 +73,38 @@ struct crypto_hash * crypto_hash_init(enum crypto_hash_alg alg, const u8 *key,
 		break;
 #endif /* CONFIG_INTERNAL_SHA512 */
 	case CRYPTO_HASH_ALG_HMAC_MD5:
-		if (key_len > sizeof(k_pad)) {
+		if (esp_key_len > sizeof(k_pad)) {
 			MD5Init(&ctx->u.md5);
-			MD5Update(&ctx->u.md5, key, key_len);
+			MD5Update(&ctx->u.md5, key, esp_key_len);
 			MD5Final(tk, &ctx->u.md5);
 			key = tk;
-			key_len = 16;
+			esp_key_len = 16;
 		}
-		os_memcpy(ctx->key, key, key_len);
-		ctx->key_len = key_len;
+		os_memcpy(ctx->key, key, esp_key_len);
+		ctx->esp_key_len = esp_key_len;
 
-		os_memcpy(k_pad, key, key_len);
-		if (key_len < sizeof(k_pad))
-			os_memset(k_pad + key_len, 0, sizeof(k_pad) - key_len);
+		os_memcpy(k_pad, key, esp_key_len);
+		if (esp_key_len < sizeof(k_pad))
+			os_memset(k_pad + esp_key_len, 0, sizeof(k_pad) - esp_key_len);
 		for (i = 0; i < sizeof(k_pad); i++)
 			k_pad[i] ^= 0x36;
 		MD5Init(&ctx->u.md5);
 		MD5Update(&ctx->u.md5, k_pad, sizeof(k_pad));
 		break;
 	case CRYPTO_HASH_ALG_HMAC_SHA1:
-		if (key_len > sizeof(k_pad)) {
+		if (esp_key_len > sizeof(k_pad)) {
 			SHA1Init(&ctx->u.sha1);
-			SHA1Update(&ctx->u.sha1, key, key_len);
+			SHA1Update(&ctx->u.sha1, key, esp_key_len);
 			SHA1Final(tk, &ctx->u.sha1);
 			key = tk;
-			key_len = 20;
+			esp_key_len = 20;
 		}
-		os_memcpy(ctx->key, key, key_len);
-		ctx->key_len = key_len;
+		os_memcpy(ctx->key, key, esp_key_len);
+		ctx->esp_key_len = esp_key_len;
 
-		os_memcpy(k_pad, key, key_len);
-		if (key_len < sizeof(k_pad))
-			os_memset(k_pad + key_len, 0, sizeof(k_pad) - key_len);
+		os_memcpy(k_pad, key, esp_key_len);
+		if (esp_key_len < sizeof(k_pad))
+			os_memset(k_pad + esp_key_len, 0, sizeof(k_pad) - esp_key_len);
 		for (i = 0; i < sizeof(k_pad); i++)
 			k_pad[i] ^= 0x36;
 		SHA1Init(&ctx->u.sha1);
@@ -112,19 +112,19 @@ struct crypto_hash * crypto_hash_init(enum crypto_hash_alg alg, const u8 *key,
 		break;
 #ifdef CONFIG_SHA256
 	case CRYPTO_HASH_ALG_HMAC_SHA256:
-		if (key_len > sizeof(k_pad)) {
+		if (esp_key_len > sizeof(k_pad)) {
 			sha256_init(&ctx->u.sha256);
-			sha256_process(&ctx->u.sha256, key, key_len);
+			sha256_process(&ctx->u.sha256, key, esp_key_len);
 			sha256_done(&ctx->u.sha256, tk);
 			key = tk;
-			key_len = 32;
+			esp_key_len = 32;
 		}
-		os_memcpy(ctx->key, key, key_len);
-		ctx->key_len = key_len;
+		os_memcpy(ctx->key, key, esp_key_len);
+		ctx->esp_key_len = esp_key_len;
 
-		os_memcpy(k_pad, key, key_len);
-		if (key_len < sizeof(k_pad))
-			os_memset(k_pad + key_len, 0, sizeof(k_pad) - key_len);
+		os_memcpy(k_pad, key, esp_key_len);
+		if (esp_key_len < sizeof(k_pad))
+			os_memset(k_pad + esp_key_len, 0, sizeof(k_pad) - esp_key_len);
 		for (i = 0; i < sizeof(k_pad); i++)
 			k_pad[i] ^= 0x36;
 		sha256_init(&ctx->u.sha256);
@@ -251,9 +251,9 @@ int crypto_hash_finish(struct crypto_hash *ctx, u8 *mac, size_t *len)
 
 		MD5Final(mac, &ctx->u.md5);
 
-		os_memcpy(k_pad, ctx->key, ctx->key_len);
-		os_memset(k_pad + ctx->key_len, 0,
-			  sizeof(k_pad) - ctx->key_len);
+		os_memcpy(k_pad, ctx->key, ctx->esp_key_len);
+		os_memset(k_pad + ctx->esp_key_len, 0,
+			  sizeof(k_pad) - ctx->esp_key_len);
 		for (i = 0; i < sizeof(k_pad); i++)
 			k_pad[i] ^= 0x5c;
 		MD5Init(&ctx->u.md5);
@@ -271,9 +271,9 @@ int crypto_hash_finish(struct crypto_hash *ctx, u8 *mac, size_t *len)
 
 		SHA1Final(mac, &ctx->u.sha1);
 
-		os_memcpy(k_pad, ctx->key, ctx->key_len);
-		os_memset(k_pad + ctx->key_len, 0,
-			  sizeof(k_pad) - ctx->key_len);
+		os_memcpy(k_pad, ctx->key, ctx->esp_key_len);
+		os_memset(k_pad + ctx->esp_key_len, 0,
+			  sizeof(k_pad) - ctx->esp_key_len);
 		for (i = 0; i < sizeof(k_pad); i++)
 			k_pad[i] ^= 0x5c;
 		SHA1Init(&ctx->u.sha1);
@@ -292,9 +292,9 @@ int crypto_hash_finish(struct crypto_hash *ctx, u8 *mac, size_t *len)
 
 		sha256_done(&ctx->u.sha256, mac);
 
-		os_memcpy(k_pad, ctx->key, ctx->key_len);
-		os_memset(k_pad + ctx->key_len, 0,
-			  sizeof(k_pad) - ctx->key_len);
+		os_memcpy(k_pad, ctx->key, ctx->esp_key_len);
+		os_memset(k_pad + ctx->esp_key_len, 0,
+			  sizeof(k_pad) - ctx->esp_key_len);
 		for (i = 0; i < sizeof(k_pad); i++)
 			k_pad[i] ^= 0x5c;
 		sha256_init(&ctx->u.sha256);
diff --git a/components/wpa_supplicant/src/crypto/crypto_ops.c b/components/wpa_supplicant/src/crypto/crypto_ops.c
index 128af4e1ae3fca08f01b9ee7979bc19cee6aa457..d87d67f7abbbcb7db756e6a874d0a2bcad12d787 100644
--- a/components/wpa_supplicant/src/crypto/crypto_ops.c
+++ b/components/wpa_supplicant/src/crypto/crypto_ops.c
@@ -36,11 +36,11 @@ static void esp_aes_decrypt(void *ctx, const u8 *crypt, u8 *plain)
 	aes_decrypt(ctx, crypt, plain);
 }
 
-static int esp_aes_gmac(const u8 *key, size_t key_len, const u8 *iv, size_t iv_len,
+static int esp_aes_gmac(const u8 *key, size_t esp_key_len, const u8 *iv, size_t iv_len,
 			const u8 *aad, size_t aad_len, u8 *tag)
 {
 #if CONFIG_GMAC
-	return aes_gmac(key, key_len, iv, iv_len, aad, aad_len, tag);
+	return aes_gmac(key, esp_key_len, iv, iv_len, aad, aad_len, tag);
 #else
 	return 0;
 #endif
diff --git a/components/wpa_supplicant/src/crypto/md5.c b/components/wpa_supplicant/src/crypto/md5.c
index f64dfd3d43cd8692c427adffe87239c9eeacaa10..359c319e15ea94cf101c92c6acd85fdf1eba0478 100644
--- a/components/wpa_supplicant/src/crypto/md5.c
+++ b/components/wpa_supplicant/src/crypto/md5.c
@@ -16,14 +16,14 @@
 /**
  * hmac_md5_vector - HMAC-MD5 over data vector (RFC 2104)
  * @key: Key for HMAC operations
- * @key_len: Length of the key in bytes
+ * @esp_key_len: Length of the key in bytes
  * @num_elem: Number of elements in the data vector
  * @addr: Pointers to the data areas
  * @len: Lengths of the data blocks
  * @mac: Buffer for the hash (16 bytes)
  * Returns: 0 on success, -1 on failure
  */
-int hmac_md5_vector(const u8 *key, size_t key_len, size_t num_elem,
+int hmac_md5_vector(const u8 *key, size_t esp_key_len, size_t num_elem,
 		    const u8 *addr[], const size_t *len, u8 *mac)
 {
 	u8 k_pad[64]; /* padding - key XORd with ipad/opad */
@@ -41,25 +41,25 @@ int hmac_md5_vector(const u8 *key, size_t key_len, size_t num_elem,
 	}
 
         /* if key is longer than 64 bytes reset it to key = MD5(key) */
-        if (key_len > 64) {
-		if (md5_vector(1, &key, &key_len, tk))
+        if (esp_key_len > 64) {
+		if (md5_vector(1, &key, &esp_key_len, tk))
 			return -1;
 		key = tk;
-		key_len = 16;
+		esp_key_len = 16;
         }
 
 	/* the HMAC_MD5 transform looks like:
 	 *
-	 * MD5(K XOR opad, MD5(K XOR ipad, text))
+	 * MD5(esp_K XOR opad, MD5(esp_K XOR ipad, text))
 	 *
-	 * where K is an n byte key
+	 * where esp_K is an n byte key
 	 * ipad is the byte 0x36 repeated 64 times
 	 * opad is the byte 0x5c repeated 64 times
 	 * and text is the data being protected */
 
 	/* start out by storing key in ipad */
 	os_memset(k_pad, 0, sizeof(k_pad));
-	os_memcpy(k_pad, key, key_len);
+	os_memcpy(k_pad, key, esp_key_len);
 
 	/* XOR key with ipad values */
 	for (i = 0; i < 64; i++)
@@ -76,7 +76,7 @@ int hmac_md5_vector(const u8 *key, size_t key_len, size_t num_elem,
 		return -1;
 
 	os_memset(k_pad, 0, sizeof(k_pad));
-	os_memcpy(k_pad, key, key_len);
+	os_memcpy(k_pad, key, esp_key_len);
 	/* XOR key with opad values */
 	for (i = 0; i < 64; i++)
 		k_pad[i] ^= 0x5c;
@@ -96,14 +96,14 @@ int hmac_md5_vector(const u8 *key, size_t key_len, size_t num_elem,
 /**
  * hmac_md5 - HMAC-MD5 over data buffer (RFC 2104)
  * @key: Key for HMAC operations
- * @key_len: Length of the key in bytes
+ * @esp_key_len: Length of the key in bytes
  * @data: Pointers to the data area
  * @data_len: Length of the data area
  * @mac: Buffer for the hash (16 bytes)
  * Returns: 0 on success, -1 on failure
  */
-int hmac_md5(const u8 *key, size_t key_len, const u8 *data, size_t data_len,
+int hmac_md5(const u8 *key, size_t esp_key_len, const u8 *data, size_t data_len,
 	      u8 *mac)
 {
-	return hmac_md5_vector(key, key_len, 1, &data, &data_len, mac);
+	return hmac_md5_vector(key, esp_key_len, 1, &data, &data_len, mac);
 }
diff --git a/components/wpa_supplicant/src/crypto/md5.h b/components/wpa_supplicant/src/crypto/md5.h
index 33f8426c57c82bb0867b3a646d90fdf9e6b04d00..3e5fbdf97dcac324991407be4bdac1ae295102cd 100644
--- a/components/wpa_supplicant/src/crypto/md5.h
+++ b/components/wpa_supplicant/src/crypto/md5.h
@@ -11,9 +11,9 @@
 
 #define MD5_MAC_LEN 16
 
-int hmac_md5_vector(const u8 *key, size_t key_len, size_t num_elem,
+int hmac_md5_vector(const u8 *key, size_t esp_key_len, size_t num_elem,
 		    const u8 *addr[], const size_t *len, u8 *mac);
-int hmac_md5(const u8 *key, size_t key_len, const u8 *data, size_t data_len,
+int hmac_md5(const u8 *key, size_t esp_key_len, const u8 *data, size_t data_len,
 	     u8 *mac);
 
 #endif /* MD5_H */
diff --git a/components/wpa_supplicant/src/crypto/sha1-internal.c b/components/wpa_supplicant/src/crypto/sha1-internal.c
index ffa04df017e37817dbf506b45bd989c0c3c61ae8..709803e29022a6715a0a61d2d9f2c8e8a1e32df0 100644
--- a/components/wpa_supplicant/src/crypto/sha1-internal.c
+++ b/components/wpa_supplicant/src/crypto/sha1-internal.c
@@ -66,7 +66,7 @@ to
 long len)
 
 The 'len' parameter was declared an int which works fine on 32 bit machines.
-However, on 16 bit machines an int is too small for the shifts being done
+However, on 16 bit machines an int is too small for the esp_shifts being done
 against
 it.  This caused the hash function to generate incorrect values if len was
 greater than 8191 (8K - 1) due to the 'len << 3' on line 3 of SHA1Update().
diff --git a/components/wpa_supplicant/src/crypto/sha1-prf.c b/components/wpa_supplicant/src/crypto/sha1-prf.c
index 13851494fb92372f8cb97ae22cd28b9f0cfed4c9..24c63477845da210b83a884c84d0df14c2197015 100644
--- a/components/wpa_supplicant/src/crypto/sha1-prf.c
+++ b/components/wpa_supplicant/src/crypto/sha1-prf.c
@@ -16,7 +16,7 @@
 /**
  * sha1_prf - SHA1-based Pseudo-Random Function (PRF) (IEEE 802.11i, 8.5.1.1)
  * @key: Key for PRF
- * @key_len: Length of the key in bytes
+ * @esp_key_len: Length of the key in bytes
  * @label: A unique label for each purpose of the PRF
  * @data: Extra data to bind into the key
  * @data_len: Length of the data
@@ -27,7 +27,7 @@
  * This function is used to derive new, cryptographically separate keys from a
  * given key (e.g., PMK in IEEE 802.11i).
  */
-int sha1_prf(const u8 *key, size_t key_len, const char *label,
+int sha1_prf(const u8 *key, size_t esp_key_len, const char *label,
 	     const u8 *data, size_t data_len, u8 *buf, size_t buf_len)
 {
 	u8 counter = 0;
@@ -48,12 +48,12 @@ int sha1_prf(const u8 *key, size_t key_len, const char *label,
 	while (pos < buf_len) {
 		plen = buf_len - pos;
 		if (plen >= SHA1_MAC_LEN) {
-			if (hmac_sha1_vector(key, key_len, 3, addr, len,
+			if (hmac_sha1_vector(key, esp_key_len, 3, addr, len,
 					     &buf[pos]))
 				return -1;
 			pos += SHA1_MAC_LEN;
 		} else {
-			if (hmac_sha1_vector(key, key_len, 3, addr, len,
+			if (hmac_sha1_vector(key, esp_key_len, 3, addr, len,
 					     hash))
 				return -1;
 			os_memcpy(&buf[pos], hash, plen);
diff --git a/components/wpa_supplicant/src/crypto/sha1-tprf.c b/components/wpa_supplicant/src/crypto/sha1-tprf.c
index c3acf19750d5a857ccaa28533f1bec3c6cb40ba1..3429f117e66e3c6c387243401194d4ad8d5e1c2f 100644
--- a/components/wpa_supplicant/src/crypto/sha1-tprf.c
+++ b/components/wpa_supplicant/src/crypto/sha1-tprf.c
@@ -15,7 +15,7 @@
 /**
  * sha1_t_prf - EAP-FAST Pseudo-Random Function (T-PRF)
  * @key: Key for PRF
- * @key_len: Length of the key in bytes
+ * @esp_key_len: Length of the key in bytes
  * @label: A unique label for each purpose of the PRF
  * @seed: Seed value to bind into the key
  * @seed_len: Length of the seed
@@ -26,7 +26,7 @@
  * This function is used to derive new, cryptographically separate keys from a
  * given key for EAP-FAST. T-PRF is defined in RFC 4851, Section 5.5.
  */
-int sha1_t_prf(const u8 *key, size_t key_len, const char *label,
+int sha1_t_prf(const u8 *key, size_t esp_key_len, const char *label,
 	       const u8 *seed, size_t seed_len, u8 *buf, size_t buf_len)
 {
 	unsigned char counter = 0;
@@ -54,7 +54,7 @@ int sha1_t_prf(const u8 *key, size_t key_len, const char *label,
 	while (pos < buf_len) {
 		counter++;
 		plen = buf_len - pos;
-		if (hmac_sha1_vector(key, key_len, 5, addr, len, hash))
+		if (hmac_sha1_vector(key, esp_key_len, 5, addr, len, hash))
 			return -1;
 		if (plen >= SHA1_MAC_LEN) {
 			os_memcpy(&buf[pos], hash, SHA1_MAC_LEN);
diff --git a/components/wpa_supplicant/src/crypto/sha1.c b/components/wpa_supplicant/src/crypto/sha1.c
index 76d7a68f26109155318f3ef136a80170065dde67..e707f43ad69fd6bcbb5a8ace427d3c79706997ef 100644
--- a/components/wpa_supplicant/src/crypto/sha1.c
+++ b/components/wpa_supplicant/src/crypto/sha1.c
@@ -16,14 +16,14 @@
 /**
  * hmac_sha1_vector - HMAC-SHA1 over data vector (RFC 2104)
  * @key: Key for HMAC operations
- * @key_len: Length of the key in bytes
+ * @esp_key_len: Length of the key in bytes
  * @num_elem: Number of elements in the data vector
  * @addr: Pointers to the data areas
  * @len: Lengths of the data blocks
  * @mac: Buffer for the hash (20 bytes)
  * Returns: 0 on success, -1 on failure
  */
-int hmac_sha1_vector(const u8 *key, size_t key_len, size_t num_elem,
+int hmac_sha1_vector(const u8 *key, size_t esp_key_len, size_t num_elem,
 		     const u8 *addr[], const size_t *len, u8 *mac)
 {
 	unsigned char k_pad[64]; /* padding - key XORd with ipad/opad */
@@ -41,25 +41,25 @@ int hmac_sha1_vector(const u8 *key, size_t key_len, size_t num_elem,
 	}
 
         /* if key is longer than 64 bytes reset it to key = SHA1(key) */
-        if (key_len > 64) {
-		if (sha1_vector(1, &key, &key_len, tk))
+        if (esp_key_len > 64) {
+		if (sha1_vector(1, &key, &esp_key_len, tk))
 			return -1;
 		key = tk;
-		key_len = 20;
+		esp_key_len = 20;
         }
 
 	/* the HMAC_SHA1 transform looks like:
 	 *
-	 * SHA1(K XOR opad, SHA1(K XOR ipad, text))
+	 * SHA1(esp_K XOR opad, SHA1(esp_K XOR ipad, text))
 	 *
-	 * where K is an n byte key
+	 * where esp_K is an n byte key
 	 * ipad is the byte 0x36 repeated 64 times
 	 * opad is the byte 0x5c repeated 64 times
 	 * and text is the data being protected */
 
 	/* start out by storing key in ipad */
 	os_memset(k_pad, 0, sizeof(k_pad));
-	os_memcpy(k_pad, key, key_len);
+	os_memcpy(k_pad, key, esp_key_len);
 	/* XOR key with ipad values */
 	for (i = 0; i < 64; i++)
 		k_pad[i] ^= 0x36;
@@ -75,7 +75,7 @@ int hmac_sha1_vector(const u8 *key, size_t key_len, size_t num_elem,
 		return -1;
 
 	os_memset(k_pad, 0, sizeof(k_pad));
-	os_memcpy(k_pad, key, key_len);
+	os_memcpy(k_pad, key, esp_key_len);
 	/* XOR key with opad values */
 	for (i = 0; i < 64; i++)
 		k_pad[i] ^= 0x5c;
@@ -95,14 +95,14 @@ int hmac_sha1_vector(const u8 *key, size_t key_len, size_t num_elem,
 /**
  * hmac_sha1 - HMAC-SHA1 over data buffer (RFC 2104)
  * @key: Key for HMAC operations
- * @key_len: Length of the key in bytes
+ * @esp_key_len: Length of the key in bytes
  * @data: Pointers to the data area
  * @data_len: Length of the data area
  * @mac: Buffer for the hash (20 bytes)
  * Returns: 0 on success, -1 of failure
  */
-int hmac_sha1(const u8 *key, size_t key_len, const u8 *data, size_t data_len,
+int hmac_sha1(const u8 *key, size_t esp_key_len, const u8 *data, size_t data_len,
 	       u8 *mac)
 {
-	return hmac_sha1_vector(key, key_len, 1, &data, &data_len, mac);
+	return hmac_sha1_vector(key, esp_key_len, 1, &data, &data_len, mac);
 }
diff --git a/components/wpa_supplicant/src/crypto/sha1.h b/components/wpa_supplicant/src/crypto/sha1.h
index 933cd81b95b3a81d8557a2afa7f33561d76d62c0..c601d5d1b9e155a83c7bad2e00db640d22fbb61d 100644
--- a/components/wpa_supplicant/src/crypto/sha1.h
+++ b/components/wpa_supplicant/src/crypto/sha1.h
@@ -11,13 +11,13 @@
 
 #define SHA1_MAC_LEN 20
 
-int hmac_sha1_vector(const u8 *key, size_t key_len, size_t num_elem,
+int hmac_sha1_vector(const u8 *key, size_t esp_key_len, size_t num_elem,
 		     const u8 *addr[], const size_t *len, u8 *mac);
-int hmac_sha1(const u8 *key, size_t key_len, const u8 *data, size_t data_len,
+int hmac_sha1(const u8 *key, size_t esp_key_len, const u8 *data, size_t data_len,
 	       u8 *mac);
-int sha1_prf(const u8 *key, size_t key_len, const char *label,
+int sha1_prf(const u8 *key, size_t esp_key_len, const char *label,
 	     const u8 *data, size_t data_len, u8 *buf, size_t buf_len);
-int sha1_t_prf(const u8 *key, size_t key_len, const char *label,
+int sha1_t_prf(const u8 *key, size_t esp_key_len, const char *label,
 	       const u8 *seed, size_t seed_len, u8 *buf, size_t buf_len);
 int __must_check tls_prf_sha1_md5(const u8 *secret, size_t secret_len,
 				  const char *label, const u8 *seed,
diff --git a/components/wpa_supplicant/src/crypto/sha256-internal.c b/components/wpa_supplicant/src/crypto/sha256-internal.c
index ff1e2ba1686d3014b011aaf577af86a8ac473329..646a8022c0d103ecf8113adc1e7a2cf4c92c526a 100644
--- a/components/wpa_supplicant/src/crypto/sha256-internal.c
+++ b/components/wpa_supplicant/src/crypto/sha256-internal.c
@@ -46,8 +46,8 @@ int sha256_vector(size_t num_elem, const u8 *addr[], const size_t *len,
 /* This is based on SHA256 implementation in LibTomCrypt that was released into
  * public domain by Tom St Denis. */
 
-/* the K array */
-static const unsigned long K[64] = {
+/* the esp_K array */
+static const unsigned long esp_K[64] = {
 	0x428a2f98UL, 0x71374491UL, 0xb5c0fbcfUL, 0xe9b5dba5UL, 0x3956c25bUL,
 	0x59f111f1UL, 0x923f82a4UL, 0xab1c5ed5UL, 0xd807aa98UL, 0x12835b01UL,
 	0x243185beUL, 0x550c7dc3UL, 0x72be5d74UL, 0x80deb1feUL, 0x9bdc06a7UL,
@@ -104,7 +104,7 @@ static int sha256_compress(struct sha256_state *md, unsigned char *buf)
 
 	/* Compress */
 #define RND(a,b,c,d,e,f,g,h,i)                          \
-	t0 = h + Sigma1(e) + Ch(e, f, g) + K[i] + W[i];	\
+	t0 = h + Sigma1(e) + Ch(e, f, g) + esp_K[i] + W[i];	\
 	t1 = Sigma0(a) + Maj(a, b, c);			\
 	d += t0;					\
 	h  = t0 + t1;
diff --git a/components/wpa_supplicant/src/crypto/sha256-prf.c b/components/wpa_supplicant/src/crypto/sha256-prf.c
index d665a9983cf8a798cbc86dca8070018f8e9d1402..656de59772f7f19dc902cf61b125eae12908b6c3 100644
--- a/components/wpa_supplicant/src/crypto/sha256-prf.c
+++ b/components/wpa_supplicant/src/crypto/sha256-prf.c
@@ -16,7 +16,7 @@
 /**
  * sha256_prf - SHA256-based Pseudo-Random Function (IEEE 802.11r, 8.5.1.5.2)
  * @key: Key for PRF
- * @key_len: Length of the key in bytes
+ * @esp_key_len: Length of the key in bytes
  * @label: A unique label for each purpose of the PRF
  * @data: Extra data to bind into the key
  * @data_len: Length of the data
@@ -27,10 +27,10 @@
  * This function is used to derive new, cryptographically separate keys from a
  * given key.
  */
-int sha256_prf(const u8 *key, size_t key_len, const char *label,
+int sha256_prf(const u8 *key, size_t esp_key_len, const char *label,
 		const u8 *data, size_t data_len, u8 *buf, size_t buf_len)
 {
-	return sha256_prf_bits(key, key_len, label, data, data_len, buf,
+	return sha256_prf_bits(key, esp_key_len, label, data, data_len, buf,
 			       buf_len * 8);
 }
 
@@ -38,7 +38,7 @@ int sha256_prf(const u8 *key, size_t key_len, const char *label,
 /**
  * sha256_prf_bits - IEEE Std 802.11-2012, 11.6.1.7.2 Key derivation function
  * @key: Key for KDF
- * @key_len: Length of the key in bytes
+ * @esp_key_len: Length of the key in bytes
  * @label: A unique label for each purpose of the PRF
  * @data: Extra data to bind into the key
  * @data_len: Length of the data
@@ -51,7 +51,7 @@ int sha256_prf(const u8 *key, size_t key_len, const char *label,
  * significant 1-7 bits of the last octet in the output are not part of the
  * requested output.
  */
-int sha256_prf_bits(const u8 *key, size_t key_len, const char *label,
+int sha256_prf_bits(const u8 *key, size_t esp_key_len, const char *label,
 		    const u8 *data, size_t data_len, u8 *buf,
 		    size_t buf_len_bits)
 {
@@ -78,12 +78,12 @@ int sha256_prf_bits(const u8 *key, size_t key_len, const char *label,
 		plen = buf_len - pos;
 		WPA_PUT_LE16(counter_le, counter);
 		if (plen >= SHA256_MAC_LEN) {
-			if (hmac_sha256_vector(key, key_len, 4, addr, len,
+			if (hmac_sha256_vector(key, esp_key_len, 4, addr, len,
 					       &buf[pos]) < 0)
 				return -1;
 			pos += SHA256_MAC_LEN;
 		} else {
-			if (hmac_sha256_vector(key, key_len, 4, addr, len,
+			if (hmac_sha256_vector(key, esp_key_len, 4, addr, len,
 					       hash) < 0)
 				return -1;
 			os_memcpy(&buf[pos], hash, plen);
diff --git a/components/wpa_supplicant/src/crypto/sha256-tlsprf.c b/components/wpa_supplicant/src/crypto/sha256-tlsprf.c
index 9045cd36b4893703008ba1cc2e975330de9cb092..3f97cc039136d6668a0e693776b5039a5512687e 100644
--- a/components/wpa_supplicant/src/crypto/sha256-tlsprf.c
+++ b/components/wpa_supplicant/src/crypto/sha256-tlsprf.c
@@ -13,7 +13,7 @@
 
 
 /**
- * tls_prf_sha256 - Pseudo-Random Function for TLS v1.2 (P_SHA256, RFC 5246)
+ * esp_tls_prf_sha256 - Pseudo-Random Function for TLS v1.2 (P_SHA256, RFC 5246)
  * @secret: Key for PRF
  * @secret_len: Length of the key in bytes
  * @label: A unique label for each purpose of the PRF
@@ -26,7 +26,7 @@
  * This function is used to derive new, cryptographically separate keys from a
  * given key in TLS. This PRF is defined in RFC 2246, Chapter 5.
  */
-int tls_prf_sha256(const u8 *secret, size_t secret_len, const char *label,
+int esp_tls_prf_sha256(const u8 *secret, size_t secret_len, const char *label,
 		   const u8 *seed, size_t seed_len, u8 *out, size_t outlen)
 {
 	size_t clen;
diff --git a/components/wpa_supplicant/src/crypto/sha256.c b/components/wpa_supplicant/src/crypto/sha256.c
index 17af964ad049f1efd7a0cac5a877dfa1e766cad7..38277b2a0de1b28c51f8410bff61172698b46558 100644
--- a/components/wpa_supplicant/src/crypto/sha256.c
+++ b/components/wpa_supplicant/src/crypto/sha256.c
@@ -16,14 +16,14 @@
 /**
  * hmac_sha256_vector - HMAC-SHA256 over data vector (RFC 2104)
  * @key: Key for HMAC operations
- * @key_len: Length of the key in bytes
+ * @esp_key_len: Length of the key in bytes
  * @num_elem: Number of elements in the data vector
  * @addr: Pointers to the data areas
  * @len: Lengths of the data blocks
  * @mac: Buffer for the hash (32 bytes)
  * Returns: 0 on success, -1 on failure
  */
-int hmac_sha256_vector(const u8 *key, size_t key_len, size_t num_elem,
+int hmac_sha256_vector(const u8 *key, size_t esp_key_len, size_t num_elem,
 		       const u8 *addr[], const size_t *len, u8 *mac)
 {
 	unsigned char k_pad[64]; /* padding - key XORd with ipad/opad */
@@ -40,25 +40,25 @@ int hmac_sha256_vector(const u8 *key, size_t key_len, size_t num_elem,
 	}
 
         /* if key is longer than 64 bytes reset it to key = SHA256(key) */
-        if (key_len > 64) {
-		if (sha256_vector(1, &key, &key_len, tk) < 0)
+        if (esp_key_len > 64) {
+		if (sha256_vector(1, &key, &esp_key_len, tk) < 0)
 			return -1;
 		key = tk;
-		key_len = 32;
+		esp_key_len = 32;
         }
 
 	/* the HMAC_SHA256 transform looks like:
 	 *
-	 * SHA256(K XOR opad, SHA256(K XOR ipad, text))
+	 * SHA256(esp_K XOR opad, SHA256(esp_K XOR ipad, text))
 	 *
-	 * where K is an n byte key
+	 * where esp_K is an n byte key
 	 * ipad is the byte 0x36 repeated 64 times
 	 * opad is the byte 0x5c repeated 64 times
 	 * and text is the data being protected */
 
 	/* start out by storing key in ipad */
 	os_memset(k_pad, 0, sizeof(k_pad));
-	os_memcpy(k_pad, key, key_len);
+	os_memcpy(k_pad, key, esp_key_len);
 	/* XOR key with ipad values */
 	for (i = 0; i < 64; i++)
 		k_pad[i] ^= 0x36;
@@ -74,7 +74,7 @@ int hmac_sha256_vector(const u8 *key, size_t key_len, size_t num_elem,
 		return -1;
 
 	os_memset(k_pad, 0, sizeof(k_pad));
-	os_memcpy(k_pad, key, key_len);
+	os_memcpy(k_pad, key, esp_key_len);
 	/* XOR key with opad values */
 	for (i = 0; i < 64; i++)
 		k_pad[i] ^= 0x5c;
@@ -91,14 +91,14 @@ int hmac_sha256_vector(const u8 *key, size_t key_len, size_t num_elem,
 /**
  * hmac_sha256 - HMAC-SHA256 over data buffer (RFC 2104)
  * @key: Key for HMAC operations
- * @key_len: Length of the key in bytes
+ * @esp_key_len: Length of the key in bytes
  * @data: Pointers to the data area
  * @data_len: Length of the data area
  * @mac: Buffer for the hash (32 bytes)
  * Returns: 0 on success, -1 on failure
  */
-int hmac_sha256(const u8 *key, size_t key_len, const u8 *data,
+int hmac_sha256(const u8 *key, size_t esp_key_len, const u8 *data,
 		size_t data_len, u8 *mac)
 {
-	return hmac_sha256_vector(key, key_len, 1, &data, &data_len, mac);
+	return hmac_sha256_vector(key, esp_key_len, 1, &data, &data_len, mac);
 }
diff --git a/components/wpa_supplicant/src/crypto/sha256.h b/components/wpa_supplicant/src/crypto/sha256.h
index 8054bbe5c5141c3da3aed30d9a62715d1feafca3..816bc7ee75fa7557f979790bb9ec40502e85a44b 100644
--- a/components/wpa_supplicant/src/crypto/sha256.h
+++ b/components/wpa_supplicant/src/crypto/sha256.h
@@ -11,16 +11,16 @@
 
 #define SHA256_MAC_LEN 32
 
-int hmac_sha256_vector(const u8 *key, size_t key_len, size_t num_elem,
+int hmac_sha256_vector(const u8 *key, size_t esp_key_len, size_t num_elem,
 		       const u8 *addr[], const size_t *len, u8 *mac);
-int hmac_sha256(const u8 *key, size_t key_len, const u8 *data,
+int hmac_sha256(const u8 *key, size_t esp_key_len, const u8 *data,
 		size_t data_len, u8 *mac);
-int sha256_prf(const u8 *key, size_t key_len, const char *label,
+int sha256_prf(const u8 *key, size_t esp_key_len, const char *label,
 	       const u8 *data, size_t data_len, u8 *buf, size_t buf_len);
-int sha256_prf_bits(const u8 *key, size_t key_len, const char *label,
+int sha256_prf_bits(const u8 *key, size_t esp_key_len, const char *label,
 		    const u8 *data, size_t data_len, u8 *buf,
 		    size_t buf_len_bits);
-int tls_prf_sha256(const u8 *secret, size_t secret_len,
+int esp_tls_prf_sha256(const u8 *secret, size_t secret_len,
 		   const char *label, const u8 *seed, size_t seed_len,
 		   u8 *out, size_t outlen);
 int hmac_sha256_kdf(const u8 *secret, size_t secret_len,
diff --git a/components/wpa_supplicant/src/crypto/sha384-prf.c b/components/wpa_supplicant/src/crypto/sha384-prf.c
index 420e78c380cd918e7c64b5d76ddba8a73ccf91c2..5383d6cbde643b07c2f265ea5389487e34c77bd0 100644
--- a/components/wpa_supplicant/src/crypto/sha384-prf.c
+++ b/components/wpa_supplicant/src/crypto/sha384-prf.c
@@ -16,7 +16,7 @@
 /**
  * sha384_prf - SHA384-based Key derivation function (IEEE 802.11ac, 11.6.1.7.2)
  * @key: Key for KDF
- * @key_len: Length of the key in bytes
+ * @esp_key_len: Length of the key in bytes
  * @label: A unique label for each purpose of the PRF
  * @data: Extra data to bind into the key
  * @data_len: Length of the data
@@ -27,10 +27,10 @@
  * This function is used to derive new, cryptographically separate keys from a
  * given key.
  */
-int sha384_prf(const u8 *key, size_t key_len, const char *label,
+int sha384_prf(const u8 *key, size_t esp_key_len, const char *label,
 	       const u8 *data, size_t data_len, u8 *buf, size_t buf_len)
 {
-	return sha384_prf_bits(key, key_len, label, data, data_len, buf,
+	return sha384_prf_bits(key, esp_key_len, label, data, data_len, buf,
 			       buf_len * 8);
 }
 
@@ -38,7 +38,7 @@ int sha384_prf(const u8 *key, size_t key_len, const char *label,
 /**
  * sha384_prf_bits - IEEE Std 802.11ac-2013, 11.6.1.7.2 Key derivation function
  * @key: Key for KDF
- * @key_len: Length of the key in bytes
+ * @esp_key_len: Length of the key in bytes
  * @label: A unique label for each purpose of the PRF
  * @data: Extra data to bind into the key
  * @data_len: Length of the data
@@ -51,7 +51,7 @@ int sha384_prf(const u8 *key, size_t key_len, const char *label,
  * significant 1-7 bits of the last octet in the output are not part of the
  * requested output.
  */
-int sha384_prf_bits(const u8 *key, size_t key_len, const char *label,
+int sha384_prf_bits(const u8 *key, size_t esp_key_len, const char *label,
 		    const u8 *data, size_t data_len, u8 *buf,
 		    size_t buf_len_bits)
 {
@@ -78,12 +78,12 @@ int sha384_prf_bits(const u8 *key, size_t key_len, const char *label,
 		plen = buf_len - pos;
 		WPA_PUT_LE16(counter_le, counter);
 		if (plen >= SHA384_MAC_LEN) {
-			if (hmac_sha384_vector(key, key_len, 4, addr, len,
+			if (hmac_sha384_vector(key, esp_key_len, 4, addr, len,
 					       &buf[pos]) < 0)
 				return -1;
 			pos += SHA384_MAC_LEN;
 		} else {
-			if (hmac_sha384_vector(key, key_len, 4, addr, len,
+			if (hmac_sha384_vector(key, esp_key_len, 4, addr, len,
 					       hash) < 0)
 				return -1;
 			os_memcpy(&buf[pos], hash, plen);
diff --git a/components/wpa_supplicant/src/crypto/sha384-tlsprf.c b/components/wpa_supplicant/src/crypto/sha384-tlsprf.c
index 9ff96ac2c7b2cfb88f16d6ad40f0b52174236dc8..b0418f85238e4a9b7b067cdb909684bc9aab1fe2 100644
--- a/components/wpa_supplicant/src/crypto/sha384-tlsprf.c
+++ b/components/wpa_supplicant/src/crypto/sha384-tlsprf.c
@@ -13,7 +13,7 @@
 
 
 /**
- * tls_prf_sha384 - Pseudo-Random Function for TLS v1.2 (P_SHA384, RFC 5246)
+ * esp_tls_prf_sha384 - Pseudo-Random Function for TLS v1.2 (P_SHA384, RFC 5246)
  * @secret: Key for PRF
  * @secret_len: Length of the key in bytes
  * @label: A unique label for each purpose of the PRF
@@ -26,7 +26,7 @@
  * This function is used to derive new, cryptographically separate keys from a
  * given key in TLS. This PRF is defined in RFC 5246, Chapter 5.
  */
-int tls_prf_sha384(const u8 *secret, size_t secret_len, const char *label,
+int esp_tls_prf_sha384(const u8 *secret, size_t secret_len, const char *label,
 		   const u8 *seed, size_t seed_len, u8 *out, size_t outlen)
 {
 	size_t clen;
diff --git a/components/wpa_supplicant/src/crypto/sha384.h b/components/wpa_supplicant/src/crypto/sha384.h
index 1a2c1edffb68bc8aa0c3c49f1c761e1b3a44b635..1e586c4e50b04951134032999fce1fdc15d318af 100644
--- a/components/wpa_supplicant/src/crypto/sha384.h
+++ b/components/wpa_supplicant/src/crypto/sha384.h
@@ -12,16 +12,16 @@
 #define SHA384_MAC_LEN 48
 #define SHA512_MAC_LEN 64
 
-int hmac_sha384_vector(const u8 *key, size_t key_len, size_t num_elem,
+int hmac_sha384_vector(const u8 *key, size_t esp_key_len, size_t num_elem,
 		       const u8 *addr[], const size_t *len, u8 *mac);
-int hmac_sha384(const u8 *key, size_t key_len, const u8 *data,
+int hmac_sha384(const u8 *key, size_t esp_key_len, const u8 *data,
 		size_t data_len, u8 *mac);
-int sha384_prf(const u8 *key, size_t key_len, const char *label,
+int sha384_prf(const u8 *key, size_t esp_key_len, const char *label,
 	       const u8 *data, size_t data_len, u8 *buf, size_t buf_len);
-int sha384_prf_bits(const u8 *key, size_t key_len, const char *label,
+int sha384_prf_bits(const u8 *key, size_t esp_key_len, const char *label,
 		    const u8 *data, size_t data_len, u8 *buf,
 		    size_t buf_len_bits);
-int tls_prf_sha384(const u8 *secret, size_t secret_len,
+int esp_tls_prf_sha384(const u8 *secret, size_t secret_len,
 		   const char *label, const u8 *seed, size_t seed_len,
 		   u8 *out, size_t outlen);
 int hmac_sha384_kdf(const u8 *secret, size_t secret_len,
diff --git a/components/wpa_supplicant/src/crypto/sha512-internal.c b/components/wpa_supplicant/src/crypto/sha512-internal.c
index c0263941c123c3b0358c6c17b693ac59f0fa46e3..63d161cd666e975f1ad194d0af6f9c340e45a99c 100644
--- a/components/wpa_supplicant/src/crypto/sha512-internal.c
+++ b/components/wpa_supplicant/src/crypto/sha512-internal.c
@@ -44,8 +44,8 @@ int sha512_vector(size_t num_elem, const u8 *addr[], const size_t *len,
 
 #define CONST64(n) n ## ULL
 
-/* the K array */
-static const u64 K[80] = {
+/* the esp_K array */
+static const u64 esp_K[80] = {
 	CONST64(0x428a2f98d728ae22), CONST64(0x7137449123ef65cd),
 	CONST64(0xb5c0fbcfec4d3b2f), CONST64(0xe9b5dba58189dbbc),
 	CONST64(0x3956c25bf348b538), CONST64(0x59f111f1b605d019),
@@ -134,7 +134,7 @@ static int sha512_compress(struct sha512_state *md, unsigned char *buf)
 
 	/* Compress */
 	for (i = 0; i < 80; i++) {
-		t0 = S[7] + Sigma1(S[4]) + Ch(S[4], S[5], S[6]) + K[i] + W[i];
+		t0 = S[7] + Sigma1(S[4]) + Ch(S[4], S[5], S[6]) + esp_K[i] + W[i];
 		t1 = Sigma0(S[0]) + Maj(S[0], S[1], S[2]);
 		S[7] = S[6];
 		S[6] = S[5];
diff --git a/components/wpa_supplicant/src/eap_peer/eap_fast.c b/components/wpa_supplicant/src/eap_peer/eap_fast.c
index 37e0ef18b70a775a46bc8bb1c7023bea51c6e873..83b4833d975740f9f384db12c42f7e87d8b9b865 100644
--- a/components/wpa_supplicant/src/eap_peer/eap_fast.c
+++ b/components/wpa_supplicant/src/eap_peer/eap_fast.c
@@ -648,7 +648,7 @@ static int eap_fast_get_phase2_key(struct eap_sm *sm,
 				   u8 *isk, size_t isk_len)
 {
 	u8 *key;
-	size_t key_len;
+	size_t esp_key_len;
 
 	os_memset(isk, 0, isk_len);
 
@@ -664,15 +664,15 @@ static int eap_fast_get_phase2_key(struct eap_sm *sm,
 
 	if (!data->phase2_method->isKeyAvailable(sm, data->phase2_priv) ||
 	    (key = data->phase2_method->getKey(sm, data->phase2_priv,
-					       &key_len)) == NULL) {
+					       &esp_key_len)) == NULL) {
 		wpa_printf(MSG_DEBUG, "EAP-FAST: Could not get key material "
 			   "from Phase 2");
 		return -1;
 	}
 
-	if (key_len > isk_len)
-		key_len = isk_len;
-	if (key_len == 32 &&
+	if (esp_key_len > isk_len)
+		esp_key_len = isk_len;
+	if (esp_key_len == 32 &&
 	    data->phase2_method->vendor == EAP_VENDOR_IETF &&
 	    data->phase2_method->method == EAP_TYPE_MSCHAPV2) {
 		/*
@@ -683,7 +683,7 @@ static int eap_fast_get_phase2_key(struct eap_sm *sm,
 		os_memcpy(isk, key + 16, 16);
 		os_memcpy(isk + 16, key, 16);
 	} else
-		os_memcpy(isk, key, key_len);
+		os_memcpy(isk, key, esp_key_len);
 	os_free(key);
 
 	return 0;
diff --git a/components/wpa_supplicant/src/eap_peer/eap_fast_pac.c b/components/wpa_supplicant/src/eap_peer/eap_fast_pac.c
index 39821ddb1a858581988c92d32e84803f447ed070..994a6f6df54fb42682470db5a2b4b77bce67669d 100644
--- a/components/wpa_supplicant/src/eap_peer/eap_fast_pac.c
+++ b/components/wpa_supplicant/src/eap_peer/eap_fast_pac.c
@@ -345,10 +345,10 @@ static const char * eap_fast_parse_pac_type(struct eap_fast_pac *pac,
 static const char * eap_fast_parse_pac_key(struct eap_fast_pac *pac, char *pos)
 {
 	u8 *key;
-	size_t key_len;
+	size_t esp_key_len;
 
-	key = eap_fast_parse_hex(pos, &key_len);
-	if (key == NULL || key_len != EAP_FAST_PAC_KEY_LEN) {
+	key = eap_fast_parse_hex(pos, &esp_key_len);
+	if (key == NULL || esp_key_len != EAP_FAST_PAC_KEY_LEN) {
 		os_free(key);
 		return "Invalid PAC-Key";
 	}
diff --git a/components/wpa_supplicant/src/eap_peer/eap_mschapv2.c b/components/wpa_supplicant/src/eap_peer/eap_mschapv2.c
index a8c99fff18042883b11c82880fa9e6562dafbed1..4ecaa85d38344718f15afe01d80c0d8697953f6d 100644
--- a/components/wpa_supplicant/src/eap_peer/eap_mschapv2.c
+++ b/components/wpa_supplicant/src/eap_peer/eap_mschapv2.c
@@ -805,14 +805,14 @@ static u8 * eap_mschapv2_getKey(struct eap_sm *sm, void *priv, size_t *len)
 {
 	struct eap_mschapv2_data *data = priv;
 	u8 *key;
-	int key_len;
+	int esp_key_len;
 
 	if (!data->master_key_valid || !data->success)
 		return NULL;
 
-	key_len = 2 * MSCHAPV2_KEY_LEN;
+	esp_key_len = 2 * MSCHAPV2_KEY_LEN;
 
-	key = os_malloc(key_len);
+	key = os_malloc(esp_key_len);
 	if (key == NULL)
 		return NULL;
 
@@ -823,9 +823,9 @@ static u8 * eap_mschapv2_getKey(struct eap_sm *sm, void *priv, size_t *len)
 				MSCHAPV2_KEY_LEN, 0, 0);
 
 	wpa_hexdump_key(MSG_DEBUG, "EAP-MSCHAPV2: Derived key",
-			key, key_len);
+			key, esp_key_len);
 
-	*len = key_len;
+	*len = esp_key_len;
 	return key;
 }
 
diff --git a/components/wpa_supplicant/src/eap_peer/eap_peap.c b/components/wpa_supplicant/src/eap_peer/eap_peap.c
index 503ad714dfaffba4496dbfdbc6d91ebfca7127f5..d60261f086f5ef4b25fd3c760834ed31fcf01702 100644
--- a/components/wpa_supplicant/src/eap_peer/eap_peap.c
+++ b/components/wpa_supplicant/src/eap_peer/eap_peap.c
@@ -223,7 +223,7 @@ eap_peap_get_isk(struct eap_sm *sm, struct eap_peap_data *data,
 		 u8 *isk, size_t isk_len)
 {
 	u8 *key;
-	size_t key_len;
+	size_t esp_key_len;
 
 	os_memset(isk, 0, isk_len);
 	if (data->phase2_method == NULL || data->phase2_priv == NULL ||
@@ -233,15 +233,15 @@ eap_peap_get_isk(struct eap_sm *sm, struct eap_peap_data *data,
 
 	if (!data->phase2_method->isKeyAvailable(sm, data->phase2_priv) ||
 	    (key = data->phase2_method->getKey(sm, data->phase2_priv,
-					       &key_len)) == NULL) {
+					       &esp_key_len)) == NULL) {
 		wpa_printf(MSG_DEBUG, "EAP-PEAP: Could not get key material "
 			   "from Phase 2");
 		return -1;
 	}
 
-	if (key_len > isk_len)
-		key_len = isk_len;
-	os_memcpy(isk, key, key_len);
+	if (esp_key_len > isk_len)
+		esp_key_len = isk_len;
+	os_memcpy(isk, key, esp_key_len);
 	os_free(key);
 
 	return 0;
diff --git a/components/wpa_supplicant/src/eap_peer/eap_peap_common.c b/components/wpa_supplicant/src/eap_peer/eap_peap_common.c
index 2cafe719755edb34a5ce60f2fab10b204a6485e7..9356acce612a90422dfe31295ab7426ee65a1cda 100644
--- a/components/wpa_supplicant/src/eap_peer/eap_peap_common.c
+++ b/components/wpa_supplicant/src/eap_peer/eap_peap_common.c
@@ -15,7 +15,7 @@
 #include "eap_peer/eap_peap_common.h"
 
 int
-peap_prfplus(int version, const u8 *key, size_t key_len,
+peap_prfplus(int version, const u8 *key, size_t esp_key_len,
 	     const char *label, const u8 *seed, size_t seed_len,
 	     u8 *buf, size_t buf_len)
 {
@@ -36,11 +36,11 @@ peap_prfplus(int version, const u8 *key, size_t key_len,
 
 	if (version == 0) {
 		/*
-		 * PRF+(K, S, LEN) = T1 | T2 | ... | Tn
-		 * T1 = HMAC-SHA1(K, S | 0x01 | 0x00 | 0x00)
-		 * T2 = HMAC-SHA1(K, T1 | S | 0x02 | 0x00 | 0x00)
+		 * PRF+(esp_K, S, LEN) = T1 | T2 | ... | Tn
+		 * T1 = HMAC-SHA1(esp_K, S | 0x01 | 0x00 | 0x00)
+		 * T2 = HMAC-SHA1(esp_K, T1 | S | 0x02 | 0x00 | 0x00)
 		 * ...
-		 * Tn = HMAC-SHA1(K, Tn-1 | S | n | 0x00 | 0x00)
+		 * Tn = HMAC-SHA1(esp_K, Tn-1 | S | n | 0x00 | 0x00)
 		 */
 
 		extra[0] = 0;
@@ -52,11 +52,11 @@ peap_prfplus(int version, const u8 *key, size_t key_len,
 		len[4] = 2;
 	} else {
 		/*
-		 * PRF (K,S,LEN) = T1 | T2 | T3 | T4 | ... where:
-		 * T1 = HMAC-SHA1(K, S | LEN | 0x01)
-		 * T2 = HMAC-SHA1 (K, T1 | S | LEN | 0x02)
-		 * T3 = HMAC-SHA1 (K, T2 | S | LEN | 0x03)
-		 * T4 = HMAC-SHA1 (K, T3 | S | LEN | 0x04)
+		 * PRF (esp_K,S,LEN) = T1 | T2 | T3 | T4 | ... where:
+		 * T1 = HMAC-SHA1(esp_K, S | LEN | 0x01)
+		 * T2 = HMAC-SHA1 (esp_K, T1 | S | LEN | 0x02)
+		 * T3 = HMAC-SHA1 (esp_K, T2 | S | LEN | 0x03)
+		 * T4 = HMAC-SHA1 (esp_K, T3 | S | LEN | 0x04)
 		 *   ...
 		 */
 
@@ -72,7 +72,7 @@ peap_prfplus(int version, const u8 *key, size_t key_len,
 	while (pos < buf_len) {
 		counter++;
 		plen = buf_len - pos;
-		if (hmac_sha1_vector(key, key_len, 5, addr, len, hash) < 0)
+		if (hmac_sha1_vector(key, esp_key_len, 5, addr, len, hash) < 0)
 			return -1;
 		if (plen >= SHA1_MAC_LEN) {
 			os_memcpy(&buf[pos], hash, SHA1_MAC_LEN);
diff --git a/components/wpa_supplicant/src/eap_peer/eap_peap_common.h b/components/wpa_supplicant/src/eap_peer/eap_peap_common.h
index 7aad0dff781d9a57e1eb69ad853a98ccfd1bbf3e..d907fd6ae65d328f20d4f35ca73b6639ae7bae1f 100644
--- a/components/wpa_supplicant/src/eap_peer/eap_peap_common.h
+++ b/components/wpa_supplicant/src/eap_peer/eap_peap_common.h
@@ -9,7 +9,7 @@
 #ifndef EAP_PEAP_COMMON_H
 #define EAP_PEAP_COMMON_H
 
-int peap_prfplus(int version, const u8 *key, size_t key_len,
+int peap_prfplus(int version, const u8 *key, size_t esp_key_len,
 		 const char *label, const u8 *seed, size_t seed_len,
 		 u8 *buf, size_t buf_len);
 
diff --git a/components/wpa_supplicant/src/rsn_supp/wpa.c b/components/wpa_supplicant/src/rsn_supp/wpa.c
index 2c5ed0d7b1111f8d129c49799fab00b271b9947c..5fc90b4c78bf77843940c64d9e5e9e93f44e32a3 100644
--- a/components/wpa_supplicant/src/rsn_supp/wpa.c
+++ b/components/wpa_supplicant/src/rsn_supp/wpa.c
@@ -59,7 +59,7 @@ u8 assoc_ie_buf[ASSOC_IE_LEN+2];
 
 void set_assoc_ie(u8 * assoc_buf);
 
-static int wpa_sm_get_key(uint8_t *ifx, int *alg, u8 *addr, int *key_idx, u8 *key, size_t key_len, enum key_flag key_flag);
+static int wpa_sm_get_key(uint8_t *ifx, int *alg, u8 *addr, int *key_idx, u8 *key, size_t esp_key_len, enum key_flag key_flag);
 
 void wpa_set_passphrase(char * passphrase, u8 *ssid, size_t ssid_len);
 
@@ -1591,7 +1591,7 @@ static int wpa_supplicant_process_1_of_2_wpa(struct wpa_sm *sm,
         }
         if (aes_unwrap(sm->ptk.kek, sm->ptk.kek_len, maxkeylen / 8, key_data, gd->gtk)) {
             #ifdef DEBUG_PRINT
-            wpa_printf(MSG_DEBUG, "WPA: AES unwrap "
+            wpa_printf(MSG_DEBUG, "WPA: AES esp_unwrap "
                 "failed - could not decrypt GTK");
             #endif
             return -1;
@@ -1837,7 +1837,7 @@ static int wpa_supplicant_decrypt_key_data(struct wpa_sm *sm,
         if (aes_unwrap(sm->ptk.kek, sm->ptk.kek_len, *key_data_len / 8,
                        key_data, buf)) {
             #ifdef DEBUG_PRINT
-            wpa_printf(MSG_DEBUG, "WPA: AES unwrap failed - "
+            wpa_printf(MSG_DEBUG, "WPA: AES esp_unwrap failed - "
                        "could not decrypt EAPOL-Key key data");
             #endif
             return -1;
@@ -2626,13 +2626,13 @@ set_assoc_ie(u8 * assoc_buf)
 int wpa_sm_set_key(struct install_key *key_sm, enum wpa_alg alg,
         u8 *addr, int key_idx, int set_tx,
         u8 *seq, size_t seq_len,
-        u8 *key, size_t key_len,
+        u8 *key, size_t esp_key_len,
         enum key_flag key_flag)
 {
     struct wpa_sm *sm = &gWpaSm;
 
     /*gtk or ptk both need check countermeasures*/
-    if (alg == WIFI_WPA_ALG_TKIP && key_idx == 0 && key_len == 32) {
+    if (alg == WIFI_WPA_ALG_TKIP && key_idx == 0 && esp_key_len == 32) {
         /* Clear the MIC error counter when setting a new PTK. */
         sm->mic_errors_seen = 0;
     }
@@ -2642,17 +2642,17 @@ int wpa_sm_set_key(struct install_key *key_sm, enum wpa_alg alg,
     memcpy(key_sm->addr, addr, ETH_ALEN);
     key_sm->key_idx = key_idx;
     key_sm->set_tx = set_tx;
-    memcpy(key_sm->key, key, key_len);
+    memcpy(key_sm->key, key, esp_key_len);
 
-    sm->install_ppkey(alg, addr, key_idx, set_tx, seq, seq_len, key, key_len, key_flag);
+    sm->install_ppkey(alg, addr, key_idx, set_tx, seq, seq_len, key, esp_key_len, key_flag);
     return 0;
 }
 
 static int
-wpa_sm_get_key(uint8_t *ifx, int *alg, u8 *addr, int *key_idx, u8 *key, size_t key_len, enum key_flag key_flag)
+wpa_sm_get_key(uint8_t *ifx, int *alg, u8 *addr, int *key_idx, u8 *key, size_t esp_key_len, enum key_flag key_flag)
 {
     struct wpa_sm *sm = &gWpaSm;
-    return sm->get_ppkey(ifx, alg, addr, key_idx, key, key_len, key_flag);
+    return sm->get_ppkey(ifx, alg, addr, key_idx, key, esp_key_len, key_flag);
 }
 
 void wpa_supplicant_clr_countermeasures(u16 *pisunicast)
diff --git a/components/wpa_supplicant/src/rsn_supp/wpa.h b/components/wpa_supplicant/src/rsn_supp/wpa.h
index 4f7a768fc660d4754ac9044f9b32104acfc80317..3c436af25b391c7046e969e5f7f85c375548e572 100644
--- a/components/wpa_supplicant/src/rsn_supp/wpa.h
+++ b/components/wpa_supplicant/src/rsn_supp/wpa.h
@@ -51,7 +51,7 @@ void wpa_sta_clear_curr_pmksa(void);
 int wpa_sm_set_key(struct install_key *sm, enum wpa_alg alg,
         u8 *addr, int key_idx, int set_tx,
         u8 *seq, size_t seq_len,
-        u8 *key, size_t key_len,
+        u8 *key, size_t esp_key_len,
         enum key_flag key_flag);
 
 int wpa_sm_set_ap_rsnxe(const u8 *ie, size_t len);
diff --git a/components/wpa_supplicant/src/rsn_supp/wpa_ft.c b/components/wpa_supplicant/src/rsn_supp/wpa_ft.c
index 0c4bad9d9c0d99e4a1b0eb91f883cee5a0c2b1e3..410f77621bcc7280179b98a901168eb45c87678c 100644
--- a/components/wpa_supplicant/src/rsn_supp/wpa_ft.c
+++ b/components/wpa_supplicant/src/rsn_supp/wpa_ft.c
@@ -606,7 +606,7 @@ static int wpa_ft_process_gtk_subelem(struct wpa_sm *sm, const u8 *gtk_elem,
 	}
 	gtk_len = gtk_elem_len - 19;
 	if (aes_unwrap(sm->ptk.kek, sm->ptk.kek_len, gtk_len / 8, gtk_elem + 11, gtk)) {
-		wpa_printf(MSG_WARNING, "FT: AES unwrap failed - could not "
+		wpa_printf(MSG_WARNING, "FT: AES esp_unwrap failed - could not "
 			   "decrypt GTK");
 		return -1;
 	}
@@ -685,7 +685,7 @@ static int wpa_ft_process_igtk_subelem(struct wpa_sm *sm, const u8 *igtk_elem,
 
 	if (aes_unwrap(sm->ptk.kek, sm->ptk.kek_len, WPA_IGTK_LEN / 8,
 		       igtk_elem + 9, igtk)) {
-		wpa_printf(MSG_WARNING, "FT: AES unwrap failed - could not "
+		wpa_printf(MSG_WARNING, "FT: AES esp_unwrap failed - could not "
 			   "decrypt IGTK");
 		return -1;
 	}
diff --git a/components/wpa_supplicant/src/rsn_supp/wpa_i.h b/components/wpa_supplicant/src/rsn_supp/wpa_i.h
index 79d8535701bf3a64d2d4c2e43845995c8264be12..62f4c980c33f64c99a371a20b715ac72b4d62937 100644
--- a/components/wpa_supplicant/src/rsn_supp/wpa_i.h
+++ b/components/wpa_supplicant/src/rsn_supp/wpa_i.h
@@ -84,9 +84,9 @@ struct wpa_sm {
     void (* sendto) (void *buffer, uint16_t len);
     void (*config_assoc_ie) (u8 proto, u8 *assoc_buf, u32 assoc_wpa_ie_len);
     void (*install_ppkey) (enum wpa_alg alg, u8 *addr, int key_idx, int set_tx,
-               u8 *seq, unsigned int seq_len, u8 *key, unsigned int key_len, enum key_flag key_flag);
+               u8 *seq, unsigned int seq_len, u8 *key, unsigned int esp_key_len, enum key_flag key_flag);
     int (*get_ppkey) (uint8_t *ifx, int *alg, uint8_t *addr, int *key_idx,
-               uint8_t *key, size_t key_len, enum key_flag key_flag);
+               uint8_t *key, size_t esp_key_len, enum key_flag key_flag);
     void (*wpa_deauthenticate)(u8 reason_code);
     void (*wpa_neg_complete)(void);
     struct wpa_gtk_data gd; //used for calllback save param
@@ -145,7 +145,7 @@ struct wpa_sm {
  *	TKIP: 6 octets, CCMP: 6 octets, IGTK: 6 octets
  * @key: key buffer; TKIP: 16-byte temporal key, 8-byte Tx Mic key,
  *	8-byte Rx Mic Key
- * @key_len: length of the key buffer in octets (WEP: 5 or 13,
+ * @esp_key_len: length of the key buffer in octets (WEP: 5 or 13,
  *	TKIP: 32, CCMP: 16, IGTK: 16)
  *
  * Returns: 0 on success, -1 on failure
@@ -156,7 +156,7 @@ struct wpa_sm {
  * individual. If only 4 keys are supported, the default key with key
  * index 0 is used as the individual key. STA must be configured to use
  * it as the default Tx key (set_tx is set) and accept Rx for all the
- * key indexes. In most cases, WPA uses only key indexes 1 and 2 for
+ * key esp_indexes. In most cases, WPA uses only key esp_indexes 1 and 2 for
  * broadcast keys, so key index 0 is available for this kind of
  * configuration.
  *
@@ -191,9 +191,9 @@ static inline int wpa_sm_mark_authenticated(struct wpa_sm *sm,
 typedef void (* WPA_SET_ASSOC_IE)(u8 proto, u8 *assoc_buf, u32 assoc_wpa_ie_len);
 
 typedef void (*WPA_INSTALL_KEY) (enum wpa_alg alg, u8 *addr, int key_idx, int set_tx,
-               u8 *seq, size_t seq_len, u8 *key, size_t key_len, enum key_flag key_flag);
+               u8 *seq, size_t seq_len, u8 *key, size_t esp_key_len, enum key_flag key_flag);
 
-typedef int (*WPA_GET_KEY) (u8 *ifx, int *alg, u8 *addt, int *keyidx, u8 *key, size_t key_len, enum key_flag key_flag);
+typedef int (*WPA_GET_KEY) (u8 *ifx, int *alg, u8 *addt, int *keyidx, u8 *key, size_t esp_key_len, enum key_flag key_flag);
 
 typedef void (*WPA_DEAUTH_FUNC)(u8 reason_code);
 
diff --git a/components/wpa_supplicant/src/tls/libtommath.h b/components/wpa_supplicant/src/tls/libtommath.h
index c3f5eee39e410c0563c3a3b19c7db1042e8bc367..d914904db3bba182711afdc1d71baa504cad0301 100644
--- a/components/wpa_supplicant/src/tls/libtommath.h
+++ b/components/wpa_supplicant/src/tls/libtommath.h
@@ -2942,7 +2942,7 @@ mp_mul_2(mp_int * a, mp_int * b)
 
 #ifdef BN_MP_MONTGOMERY_CALC_NORMALIZATION_C
 /*
- * shifts with subtractions when the result is greater than b.
+ * esp_shifts with subtractions when the result is greater than b.
  *
  * The method is slightly modified to shift B unconditionally up to just under
  * the leading bit of b.  This saves a lot of multiple precision shifting.
diff --git a/components/wpa_supplicant/src/tls/tlsv1_client_ocsp.c b/components/wpa_supplicant/src/tls/tlsv1_client_ocsp.c
index 128f4b5b9e7bbe28e6cafa15404fbc43e6957a03..49e7b8bc6a7c6a506a7ccb0b55e6b3fe6cda2d55 100644
--- a/components/wpa_supplicant/src/tls/tlsv1_client_ocsp.c
+++ b/components/wpa_supplicant/src/tls/tlsv1_client_ocsp.c
@@ -253,7 +253,7 @@ static int tls_process_ocsp_single_response(struct tlsv1_client *conn,
 	/* thisUpdate  GeneralizedTime */
 	if (asn1_get_next(pos, end - pos, &hdr) < 0 ||
 	    !asn1_is_generalizedtime(&hdr) ||
-	    x509_parse_time(hdr.payload, hdr.length, hdr.tag, &update) < 0) {
+	    esp_x509_parse_time(hdr.payload, hdr.length, hdr.tag, &update) < 0) {
 		wpa_printf(MSG_DEBUG, "OCSP: Failed to parse thisUpdate");
 		return -1;
 	}
@@ -274,7 +274,7 @@ static int tls_process_ocsp_single_response(struct tlsv1_client *conn,
 
 			if (asn1_get_next(hdr.payload, hdr.length, &hdr) < 0 ||
 			    !asn1_is_generalizedtime(&hdr) ||
-			    x509_parse_time(hdr.payload, hdr.length, hdr.tag,
+			    esp_x509_parse_time(hdr.payload, hdr.length, hdr.tag,
 					    &update) < 0) {
 				wpa_printf(MSG_DEBUG,
 					   "OCSP: Failed to parse nextUpdate");
@@ -537,7 +537,7 @@ tls_process_basic_ocsp_response(struct tlsv1_client *conn,
 	/* producedAt  GeneralizedTime */
 	if (asn1_get_next(pos, end - pos, &hdr) < 0 ||
 	    !asn1_is_generalizedtime(&hdr) ||
-	    x509_parse_time(hdr.payload, hdr.length, hdr.tag,
+	    esp_x509_parse_time(hdr.payload, hdr.length, hdr.tag,
 			    &produced_at) < 0) {
 		wpa_printf(MSG_DEBUG, "OCSP: Failed to parse producedAt");
 		goto fail;
diff --git a/components/wpa_supplicant/src/tls/tlsv1_common.c b/components/wpa_supplicant/src/tls/tlsv1_common.c
index 06c9640c8dd09bbcce43f7eedddecec6862afbb9..0e7c1f096cde178de067178d2ea8eeed0580816f 100644
--- a/components/wpa_supplicant/src/tls/tlsv1_common.c
+++ b/components/wpa_supplicant/src/tls/tlsv1_common.c
@@ -323,7 +323,7 @@ int tls_prf(u16 ver, const u8 *secret, size_t secret_len, const char *label,
 {
 #ifdef CONFIG_TLSV12
 	if (ver >= TLS_VERSION_1_2) {
-		tls_prf_sha256(secret, secret_len, label, seed, seed_len,
+		esp_tls_prf_sha256(secret, secret_len, label, seed, seed_len,
 			       out, outlen);
 		return 0;
 	}
diff --git a/components/wpa_supplicant/src/tls/x509v3.c b/components/wpa_supplicant/src/tls/x509v3.c
index 1bbd80ade8da8768895739c0cd518eea1daf7af4..c5465afed2b358c9a2bba420a0e3096461371d95 100644
--- a/components/wpa_supplicant/src/tls/x509v3.c
+++ b/components/wpa_supplicant/src/tls/x509v3.c
@@ -570,7 +570,7 @@ static int parse_uint4(const char *pos, size_t len)
 }
 
 
-int x509_parse_time(const u8 *buf, size_t len, u8 asn1_tag, os_time_t *val)
+int esp_x509_parse_time(const u8 *buf, size_t len, u8 asn1_tag, os_time_t *val)
 {
 	const char *pos, *end;
 	int year, month, day, hour, min, sec;
@@ -720,7 +720,7 @@ static int x509_parse_validity(const u8 *buf, size_t len,
 
 	if (asn1_get_next(pos, plen, &hdr) < 0 ||
 	    (!asn1_is_utctime(&hdr) && !asn1_is_generalizedtime(&hdr)) ||
-	    x509_parse_time(hdr.payload, hdr.length, hdr.tag,
+	    esp_x509_parse_time(hdr.payload, hdr.length, hdr.tag,
 			    &cert->not_before) < 0) {
 		wpa_hexdump_ascii(MSG_DEBUG, "X509: Failed to parse notBefore "
 				  "Time", hdr.payload, hdr.length);
@@ -732,7 +732,7 @@ static int x509_parse_validity(const u8 *buf, size_t len,
 
 	if (asn1_get_next(pos, plen, &hdr) < 0 ||
 	    (!asn1_is_utctime(&hdr) && !asn1_is_generalizedtime(&hdr)) ||
-	    x509_parse_time(hdr.payload, hdr.length, hdr.tag,
+	    esp_x509_parse_time(hdr.payload, hdr.length, hdr.tag,
 			    &cert->not_after) < 0) {
 		wpa_hexdump_ascii(MSG_DEBUG, "X509: Failed to parse notAfter "
 				  "Time", hdr.payload, hdr.length);
diff --git a/components/wpa_supplicant/src/tls/x509v3.h b/components/wpa_supplicant/src/tls/x509v3.h
index e3b108ff43817073a0e2d54558e260e723a73c21..5dd179808670343a76cc81eb899f7e1cc8411c3f 100644
--- a/components/wpa_supplicant/src/tls/x509v3.h
+++ b/components/wpa_supplicant/src/tls/x509v3.h
@@ -136,7 +136,7 @@ int x509_parse_algorithm_identifier(const u8 *buf, size_t len,
 				    const u8 **next);
 int x509_parse_name(const u8 *buf, size_t len, struct x509_name *name,
 		    const u8 **next);
-int x509_parse_time(const u8 *buf, size_t len, u8 asn1_tag, os_time_t *val);
+int esp_x509_parse_time(const u8 *buf, size_t len, u8 asn1_tag, os_time_t *val);
 struct x509_certificate * x509_certificate_parse(const u8 *buf, size_t len);
 void x509_free_name(struct x509_name *name);
 void x509_name_string(struct x509_name *name, char *buf, size_t len);
diff --git a/components/wpa_supplicant/src/wps/wps.h b/components/wpa_supplicant/src/wps/wps.h
index 6ba008b4ea6a7bb902196b429835a860786f68ac..2f2170480fd7d3d1456769859aa2dab921396c15 100644
--- a/components/wpa_supplicant/src/wps/wps.h
+++ b/components/wpa_supplicant/src/wps/wps.h
@@ -38,7 +38,7 @@ struct wps_parse_attr;
  * @encr_type: Encryption Type (WPS_ENCR_NONE, .. flags)
  * @key_idx: Key index
  * @key: Key
- * @key_len: Key length in octets
+ * @esp_key_len: Key length in octets
  * @mac_addr: MAC address of the Credential receiver
  * @cred_attr: Unparsed Credential attribute data (used only in cred_cb());
  *	this may be %NULL, if not used
@@ -51,7 +51,7 @@ struct wps_credential {
 	u16 encr_type;
 	u8 key_idx;
 	u8 key[64];
-	size_t key_len;
+	size_t esp_key_len;
 	u8 mac_addr[ETH_ALEN];
 	const u8 *cred_attr;
 	size_t cred_attr_len;
diff --git a/components/wpa_supplicant/src/wps/wps_attr_process.c b/components/wpa_supplicant/src/wps/wps_attr_process.c
index 44436a4862497594e55b2176840b207732fe1ef5..a266b735982803efcc942d16c193d29905949f7f 100644
--- a/components/wpa_supplicant/src/wps/wps_attr_process.c
+++ b/components/wpa_supplicant/src/wps/wps_attr_process.c
@@ -167,7 +167,7 @@ static int wps_process_cred_network_key_idx(struct wps_credential *cred,
 
 
 static int wps_process_cred_network_key(struct wps_credential *cred,
-					const u8 *key, size_t key_len)
+					const u8 *key, size_t esp_key_len)
 {
 	if (key == NULL) {
 		wpa_printf(MSG_DEBUG, "WPS: Credential did not include "
@@ -182,10 +182,10 @@ static int wps_process_cred_network_key(struct wps_credential *cred,
 		return -1;
 	}
 
-	wpa_hexdump_key(MSG_DEBUG, "WPS: Network Key", key, key_len);
-	if (key_len <= sizeof(cred->key)) {
-		os_memcpy(cred->key, key, key_len);
-		cred->key_len = key_len;
+	wpa_hexdump_key(MSG_DEBUG, "WPS: Network Key", key, esp_key_len);
+	if (esp_key_len <= sizeof(cred->key)) {
+		os_memcpy(cred->key, key, esp_key_len);
+		cred->esp_key_len = esp_key_len;
 	}
 
 	return 0;
@@ -211,13 +211,13 @@ static int wps_process_cred_mac_addr(struct wps_credential *cred,
 static int wps_workaround_cred_key(struct wps_credential *cred)
 {
 	if (cred->auth_type & (WPS_AUTH_WPAPSK | WPS_AUTH_WPA2PSK) &&
-	    cred->key_len > 8 && cred->key_len < 64 &&
-	    cred->key[cred->key_len - 1] == 0) {
+	    cred->esp_key_len > 8 && cred->esp_key_len < 64 &&
+	    cred->key[cred->esp_key_len - 1] == 0) {
 #ifdef CONFIG_WPS_STRICT
 		wpa_printf(MSG_INFO, "WPS: WPA/WPA2-Personal passphrase uses "
 			   "forbidden NULL termination");
 		wpa_hexdump_ascii_key(MSG_INFO, "WPS: Network Key",
-				      cred->key, cred->key_len);
+				      cred->key, cred->esp_key_len);
 		return -1;
 #else /* CONFIG_WPS_STRICT */
 		/*
@@ -227,16 +227,16 @@ static int wps_workaround_cred_key(struct wps_credential *cred)
 		 */
 		wpa_printf(MSG_DEBUG, "WPS: Workaround - remove NULL "
 			   "termination from ASCII passphrase");
-		cred->key_len--;
+		cred->esp_key_len--;
 #endif /* CONFIG_WPS_STRICT */
 	}
 
 
 	if (cred->auth_type & (WPS_AUTH_WPAPSK | WPS_AUTH_WPA2PSK) &&
-	    (cred->key_len < 8 || has_ctrl_char(cred->key, cred->key_len))) {
+	    (cred->esp_key_len < 8 || has_ctrl_char(cred->key, cred->esp_key_len))) {
 		wpa_printf(MSG_INFO, "WPS: Reject credential with invalid WPA/WPA2-Personal passphrase");
 		wpa_hexdump_ascii_key(MSG_INFO, "WPS: Network Key",
-				      cred->key, cred->key_len);
+				      cred->key, cred->esp_key_len);
 		return -1;
 	}
 
diff --git a/components/wpa_supplicant/src/wps/wps_common.c b/components/wpa_supplicant/src/wps/wps_common.c
index 335e53b5836b5f4dad3ed0e5934775bd2331bed8..e6afec35c38e1e459da594c83e50acd6552d3977 100644
--- a/components/wpa_supplicant/src/wps/wps_common.c
+++ b/components/wpa_supplicant/src/wps/wps_common.c
@@ -407,7 +407,7 @@ struct wpabuf * wps_get_oob_cred(struct wps_context *wps, int rf_band,
 		cred.auth_type = WPS_AUTH_WPAPSK | WPS_AUTH_WPA2PSK;
 		cred.encr_type = WPS_ENCR_TKIP | WPS_ENCR_AES;
 		os_memcpy(cred.key, data.new_psk, data.new_psk_len);
-		cred.key_len = data.new_psk_len;
+		cred.esp_key_len = data.new_psk_len;
 
 		wps->wps_state = WPS_STATE_CONFIGURED;
 		wpa_hexdump_ascii_key(MSG_DEBUG,
diff --git a/components/wpa_supplicant/src/wps/wps_registrar.c b/components/wpa_supplicant/src/wps/wps_registrar.c
index d5fa424b5c47e4ef3cc190b34e34ffb58af0356d..922841222597a32be9246019ae9e1e5d2178c731 100644
--- a/components/wpa_supplicant/src/wps/wps_registrar.c
+++ b/components/wpa_supplicant/src/wps/wps_registrar.c
@@ -1576,12 +1576,12 @@ static int wps_build_cred_network_key(struct wpabuf *msg,
 				      const struct wps_credential *cred)
 {
 	wpa_printf(MSG_DEBUG, "WPS:  * Network Key (len=%d)",
-		   (int) cred->key_len);
+		   (int) cred->esp_key_len);
 	wpa_hexdump_key(MSG_DEBUG, "WPS: Network Key",
-			cred->key, cred->key_len);
+			cred->key, cred->esp_key_len);
 	wpabuf_put_be16(msg, ATTR_NETWORK_KEY);
-	wpabuf_put_be16(msg, cred->key_len);
-	wpabuf_put_data(msg, cred->key, cred->key_len);
+	wpabuf_put_be16(msg, cred->esp_key_len);
+	wpabuf_put_data(msg, cred->key, cred->esp_key_len);
 	return 0;
 }
 
@@ -1656,7 +1656,7 @@ int wps_build_cred(struct wps_data *wps, struct wpabuf *msg)
 			os_memcpy(wps->cred.key,
 				  reg->multi_ap_backhaul_network_key,
 				  reg->multi_ap_backhaul_network_key_len);
-			wps->cred.key_len =
+			wps->cred.esp_key_len =
 				reg->multi_ap_backhaul_network_key_len;
 		}
 		goto use_provided;
@@ -1746,19 +1746,19 @@ int wps_build_cred(struct wps_data *wps, struct wpabuf *msg)
 		wpa_hexdump_ascii_key(MSG_DEBUG, "WPS: Generated passphrase",
 				      wps->new_psk, wps->new_psk_len);
 		os_memcpy(wps->cred.key, wps->new_psk, wps->new_psk_len);
-		wps->cred.key_len = wps->new_psk_len;
+		wps->cred.esp_key_len = wps->new_psk_len;
 	} else if (wps_cp_lookup_pskfile(reg, wps->mac_addr_e, &pskfile_psk)) {
 		wpa_hexdump_key(MSG_DEBUG, "WPS: Use PSK from wpa_psk_file",
 				pskfile_psk, PMK_LEN);
 		wpa_snprintf_hex(hex, sizeof(hex), pskfile_psk, PMK_LEN);
 		os_memcpy(wps->cred.key, hex, PMK_LEN * 2);
-		wps->cred.key_len = PMK_LEN * 2;
+		wps->cred.esp_key_len = PMK_LEN * 2;
 	} else if (!wps->wps->registrar->force_per_enrollee_psk &&
 		   wps->use_psk_key && wps->wps->psk_set) {
 		wpa_printf(MSG_DEBUG, "WPS: Use PSK format for Network Key");
 		wpa_snprintf_hex(hex, sizeof(hex), wps->wps->psk, PMK_LEN);
 		os_memcpy(wps->cred.key, hex, PMK_LEN * 2);
-		wps->cred.key_len = PMK_LEN * 2;
+		wps->cred.esp_key_len = PMK_LEN * 2;
 	} else
 		if ((!wps->wps->registrar->force_per_enrollee_psk ||
 		    wps->wps->use_passphrase) && wps->wps->network_key) {
@@ -1766,7 +1766,7 @@ int wps_build_cred(struct wps_data *wps, struct wpabuf *msg)
 			   "WPS: Use passphrase format for Network key");
 		os_memcpy(wps->cred.key, wps->wps->network_key,
 			  wps->wps->network_key_len);
-		wps->cred.key_len = wps->wps->network_key_len;
+		wps->cred.esp_key_len = wps->wps->network_key_len;
 	} else if (wps->auth_type & (WPS_AUTH_WPAPSK | WPS_AUTH_WPA2PSK)) {
 		/* Generate a random per-device PSK */
 		os_free(wps->new_psk);
@@ -1787,7 +1787,7 @@ int wps_build_cred(struct wps_data *wps, struct wpabuf *msg)
 		wpa_snprintf_hex(hex, sizeof(hex), wps->new_psk,
 				 wps->new_psk_len);
 		os_memcpy(wps->cred.key, hex, wps->new_psk_len * 2);
-		wps->cred.key_len = wps->new_psk_len * 2;
+		wps->cred.esp_key_len = wps->new_psk_len * 2;
 	}
 #endif
 
@@ -1806,7 +1806,7 @@ use_provided:
 		stub.auth_type = WPS_AUTH_WPA2PSK;
 		stub.encr_type = WPS_ENCR_AES;
 		os_memcpy(stub.key, "stub psk", 9);
-		stub.key_len = 9;
+		stub.esp_key_len = 9;
 		os_memcpy(stub.mac_addr, wps->mac_addr_e, ETH_ALEN);
 		wps_build_credential(cred, &stub);
 		wpa_hexdump_buf(MSG_DEBUG, "WPS: Stub Credential", cred);
@@ -2905,7 +2905,7 @@ static void wps_cred_update(struct wps_credential *dst,
 	dst->encr_type = src->encr_type;
 	dst->key_idx = src->key_idx;
 	os_memcpy(dst->key, src->key, sizeof(dst->key));
-	dst->key_len = src->key_len;
+	dst->esp_key_len = src->esp_key_len;
 }
 
 
@@ -3341,7 +3341,7 @@ static enum wps_process_res wps_process_wsc_done(struct wps_data *wps,
 			cred.encr_type = WPS_ENCR_TKIP | WPS_ENCR_AES;
 		}
 		os_memcpy(cred.key, wps->new_psk, wps->new_psk_len);
-		cred.key_len = wps->new_psk_len;
+		cred.esp_key_len = wps->new_psk_len;
 
 		wps->wps->wps_state = WPS_STATE_CONFIGURED;
 		wpa_hexdump_ascii_key(MSG_DEBUG,
diff --git a/components/wpa_supplicant/src/wps/wps_validate.c b/components/wpa_supplicant/src/wps/wps_validate.c
index 96631ef8cf4c783dbca2ec0ca7c4423d65411135..6586012b9ed05a0f2d5db4dc87c0dbb2d7bb27ee 100644
--- a/components/wpa_supplicant/src/wps/wps_validate.c
+++ b/components/wpa_supplicant/src/wps/wps_validate.c
@@ -984,7 +984,7 @@ static int wps_validate_network_idx(const u8 *idx, int mandatory)
 }
 
 
-static int wps_validate_network_key(const u8 *key, size_t key_len,
+static int wps_validate_network_key(const u8 *key, size_t esp_key_len,
 				    const u8 *encr_type, int mandatory)
 {
 	if (key == NULL) {
@@ -996,10 +996,10 @@ static int wps_validate_network_key(const u8 *key, size_t key_len,
 		return 0;
 	}
 	if (((encr_type == NULL || WPA_GET_BE16(encr_type) != WPS_ENCR_WEP) &&
-	     key_len > 8 && key_len < 64 && key[key_len - 1] == 0) ||
-	    key_len > 64) {
+	     esp_key_len > 8 && esp_key_len < 64 && key[esp_key_len - 1] == 0) ||
+	    esp_key_len > 64) {
 		wpa_hexdump_ascii_key(MSG_INFO, "WPS-STRICT: Invalid Network "
-				      "Key attribute value", key, key_len);
+				      "Key attribute value", key, esp_key_len);
 		return -1;
 	}
 	return 0;
diff --git a/components/wpa_supplicant/test/test_crypto.c b/components/wpa_supplicant/test/test_crypto.c
index f67224871a5be6f371086f57edbbdd87e057b390..1996cfb54879ed96dde6a897ca21ada415626d82 100644
--- a/components/wpa_supplicant/test/test_crypto.c
+++ b/components/wpa_supplicant/test/test_crypto.c
@@ -322,7 +322,7 @@ TEST_CASE("Test crypto lib bignum apis", "[wpa_crypto]")
  * (assumes len is an exact multiple of sizeof mbedtls_mpi_uint)
  * Allocate a new memory as well so that it can be freed.
  */
-static inline void ecp_mpi_load( mbedtls_mpi *X, const mbedtls_mpi_uint *p, size_t len )
+static inline void esp_ecp_mpi_load( mbedtls_mpi *X, const mbedtls_mpi_uint *p, size_t len )
 {
     X->MBEDTLS_PRIVATE(s) = 1;
     X->MBEDTLS_PRIVATE(n) = len / sizeof( mbedtls_mpi_uint );
@@ -334,13 +334,13 @@ static inline void ecp_mpi_load( mbedtls_mpi *X, const mbedtls_mpi_uint *p, size
 TEST_CASE("Test crypto lib ECC apis", "[wpa_crypto]")
 {
 
-    static const mbedtls_mpi_uint secp256r1_gx[] = {
+    static const mbedtls_mpi_uint esp_secp256r1_gx[] = {
         BYTES_TO_T_UINT_8( 0x96, 0xC2, 0x98, 0xD8, 0x45, 0x39, 0xA1, 0xF4 ),
         BYTES_TO_T_UINT_8( 0xA0, 0x33, 0xEB, 0x2D, 0x81, 0x7D, 0x03, 0x77 ),
         BYTES_TO_T_UINT_8( 0xF2, 0x40, 0xA4, 0x63, 0xE5, 0xE6, 0xBC, 0xF8 ),
         BYTES_TO_T_UINT_8( 0x47, 0x42, 0x2C, 0xE1, 0xF2, 0xD1, 0x17, 0x6B ),
     };
-    static const mbedtls_mpi_uint secp256r1_gy[] = {
+    static const mbedtls_mpi_uint esp_secp256r1_gy[] = {
         BYTES_TO_T_UINT_8( 0xF5, 0x51, 0xBF, 0x37, 0x68, 0x40, 0xB6, 0xCB ),
         BYTES_TO_T_UINT_8( 0xCE, 0x5E, 0x31, 0x6B, 0x57, 0x33, 0xCE, 0x2B ),
         BYTES_TO_T_UINT_8( 0x16, 0x9E, 0x0F, 0x7C, 0x4A, 0xEB, 0xE7, 0x8E ),
@@ -392,13 +392,13 @@ TEST_CASE("Test crypto lib ECC apis", "[wpa_crypto]")
         TEST_ASSERT_NOT_NULL(q);
         TEST_ASSERT_NOT_NULL(r);
 
-        mbedtls_mpi_init( &num );
-        mbedtls_mpi_lset( &num, 3 );
+        esp_mbedtls_mpi_init( &num );
+        esp_mbedtls_mpi_lset( &num, 3 );
 
-        ecp_mpi_load(& ((mbedtls_ecp_point *)p)->MBEDTLS_PRIVATE(X), secp256r1_gx, sizeof(secp256r1_gx));
-        ecp_mpi_load(& ((mbedtls_ecp_point *)p)->MBEDTLS_PRIVATE(Y), secp256r1_gy, sizeof(secp256r1_gy));
+        esp_ecp_mpi_load(& ((mbedtls_ecp_point *)p)->MBEDTLS_PRIVATE(X), esp_secp256r1_gx, sizeof(esp_secp256r1_gx));
+        esp_ecp_mpi_load(& ((mbedtls_ecp_point *)p)->MBEDTLS_PRIVATE(Y), esp_secp256r1_gy, sizeof(esp_secp256r1_gy));
 
-        mbedtls_mpi_lset((&((mbedtls_ecp_point *)p)->MBEDTLS_PRIVATE(Z)), 1);
+        esp_mbedtls_mpi_lset((&((mbedtls_ecp_point *)p)->MBEDTLS_PRIVATE(Z)), 1);
 
         TEST_ASSERT(crypto_ec_point_mul(e, p, (crypto_bignum *) &num, q) == 0); //q = 3p
 
@@ -407,7 +407,7 @@ TEST_CASE("Test crypto lib ECC apis", "[wpa_crypto]")
 
         TEST_ASSERT(crypto_ec_point_cmp(e, q, r) == 0);
 
-        mbedtls_mpi_free( &num );
+        esp_mbedtls_mpi_free( &num );
         crypto_ec_point_deinit(p, 1);
         crypto_ec_point_deinit(q, 1);
         crypto_ec_point_deinit(r, 1);
@@ -431,13 +431,13 @@ TEST_CASE("Test crypto lib ECC apis", "[wpa_crypto]")
         TEST_ASSERT_NOT_NULL(q);
         TEST_ASSERT_NOT_NULL(r);
 
-        mbedtls_mpi_init( &num );
-        mbedtls_mpi_lset( &num, 100 );
+        esp_mbedtls_mpi_init( &num );
+        esp_mbedtls_mpi_lset( &num, 100 );
 
-        ecp_mpi_load(& ((mbedtls_ecp_point *)p)->MBEDTLS_PRIVATE(X), secp256r1_gx, sizeof(secp256r1_gx));
-        ecp_mpi_load(& ((mbedtls_ecp_point *)p)->MBEDTLS_PRIVATE(Y), secp256r1_gy, sizeof(secp256r1_gy));
+        esp_ecp_mpi_load(& ((mbedtls_ecp_point *)p)->MBEDTLS_PRIVATE(X), esp_secp256r1_gx, sizeof(esp_secp256r1_gx));
+        esp_ecp_mpi_load(& ((mbedtls_ecp_point *)p)->MBEDTLS_PRIVATE(Y), esp_secp256r1_gy, sizeof(esp_secp256r1_gy));
 
-        mbedtls_mpi_lset((&((mbedtls_ecp_point *)p)->MBEDTLS_PRIVATE(Z)), 1);
+        esp_mbedtls_mpi_lset((&((mbedtls_ecp_point *)p)->MBEDTLS_PRIVATE(Z)), 1);
 
         TEST_ASSERT(crypto_ec_point_mul(e, p, (crypto_bignum *) &num, q) == 0);
         TEST_ASSERT(crypto_ec_point_mul(e, p, (crypto_bignum *) &num, r) == 0);
@@ -447,7 +447,7 @@ TEST_CASE("Test crypto lib ECC apis", "[wpa_crypto]")
 
         TEST_ASSERT(crypto_ec_point_is_at_infinity(e, r));
 
-        mbedtls_mpi_free( &num );
+        esp_mbedtls_mpi_free( &num );
         crypto_ec_point_deinit(p, 1);
         crypto_ec_point_deinit(q, 1);
         crypto_ec_point_deinit(r, 1);
@@ -467,13 +467,13 @@ TEST_CASE("Test crypto lib ECC apis", "[wpa_crypto]")
         TEST_ASSERT_NOT_NULL(p);
         TEST_ASSERT_NOT_NULL(q);
 
-        mbedtls_mpi_init( &num );
-        mbedtls_mpi_lset( &num, 50 );
+        esp_mbedtls_mpi_init( &num );
+        esp_mbedtls_mpi_lset( &num, 50 );
 
-        ecp_mpi_load(& ((mbedtls_ecp_point *)p)->MBEDTLS_PRIVATE(X), secp256r1_gx, sizeof(secp256r1_gx));
-        ecp_mpi_load(& ((mbedtls_ecp_point *)p)->MBEDTLS_PRIVATE(Y), secp256r1_gy, sizeof(secp256r1_gy));
+        esp_ecp_mpi_load(& ((mbedtls_ecp_point *)p)->MBEDTLS_PRIVATE(X), esp_secp256r1_gx, sizeof(esp_secp256r1_gx));
+        esp_ecp_mpi_load(& ((mbedtls_ecp_point *)p)->MBEDTLS_PRIVATE(Y), esp_secp256r1_gy, sizeof(esp_secp256r1_gy));
 
-        mbedtls_mpi_lset((&((mbedtls_ecp_point *)p)->MBEDTLS_PRIVATE(Z)), 1);
+        esp_mbedtls_mpi_lset((&((mbedtls_ecp_point *)p)->MBEDTLS_PRIVATE(Z)), 1);
 
         /* Generator should always be on the curve*/
         TEST_ASSERT(crypto_ec_point_is_on_curve(e, p));
@@ -483,7 +483,7 @@ TEST_CASE("Test crypto lib ECC apis", "[wpa_crypto]")
         TEST_ASSERT(crypto_ec_point_is_on_curve(e, q));
 
 
-        mbedtls_mpi_free( &num );
+        esp_mbedtls_mpi_free( &num );
         crypto_ec_point_deinit(p, 1);
         crypto_ec_point_deinit(q, 1);
         crypto_ec_deinit(e);
@@ -505,19 +505,19 @@ TEST_CASE("Test crypto lib ECC apis", "[wpa_crypto]")
         TEST_ASSERT_NOT_NULL(q);
         TEST_ASSERT_NOT_NULL(r);
 
-        mbedtls_mpi_init( &num );
-        mbedtls_mpi_lset( &num, 50 );
+        esp_mbedtls_mpi_init( &num );
+        esp_mbedtls_mpi_lset( &num, 50 );
 
-        ecp_mpi_load(& ((mbedtls_ecp_point *)p)->MBEDTLS_PRIVATE(X), secp256r1_gx, sizeof(secp256r1_gx));
-        ecp_mpi_load(& ((mbedtls_ecp_point *)p)->MBEDTLS_PRIVATE(Y), secp256r1_gy, sizeof(secp256r1_gy));
+        esp_ecp_mpi_load(& ((mbedtls_ecp_point *)p)->MBEDTLS_PRIVATE(X), esp_secp256r1_gx, sizeof(esp_secp256r1_gx));
+        esp_ecp_mpi_load(& ((mbedtls_ecp_point *)p)->MBEDTLS_PRIVATE(Y), esp_secp256r1_gy, sizeof(esp_secp256r1_gy));
 
-        mbedtls_mpi_lset((&((mbedtls_ecp_point *)p)->MBEDTLS_PRIVATE(Z)), 1);
+        esp_mbedtls_mpi_lset((&((mbedtls_ecp_point *)p)->MBEDTLS_PRIVATE(Z)), 1);
 
-        mbedtls_mpi_copy(&((mbedtls_ecp_point *)q)->MBEDTLS_PRIVATE(X), &((mbedtls_ecp_point *)p)->MBEDTLS_PRIVATE(X));
-        mbedtls_mpi_copy(&((mbedtls_ecp_point *)r)->MBEDTLS_PRIVATE(X), &((mbedtls_ecp_point *)p)->MBEDTLS_PRIVATE(X));
+        esp_mbedtls_mpi_copy(&((mbedtls_ecp_point *)q)->MBEDTLS_PRIVATE(X), &((mbedtls_ecp_point *)p)->MBEDTLS_PRIVATE(X));
+        esp_mbedtls_mpi_copy(&((mbedtls_ecp_point *)r)->MBEDTLS_PRIVATE(X), &((mbedtls_ecp_point *)p)->MBEDTLS_PRIVATE(X));
 
-        mbedtls_mpi_lset((&((mbedtls_ecp_point *)q)->MBEDTLS_PRIVATE(Z)), 1);
-        mbedtls_mpi_lset((&((mbedtls_ecp_point *)r)->MBEDTLS_PRIVATE(Z)), 1);
+        esp_mbedtls_mpi_lset((&((mbedtls_ecp_point *)q)->MBEDTLS_PRIVATE(Z)), 1);
+        esp_mbedtls_mpi_lset((&((mbedtls_ecp_point *)r)->MBEDTLS_PRIVATE(Z)), 1);
 
         TEST_ASSERT(crypto_ec_point_solve_y_coord(e, q, (crypto_bignum *) & ((mbedtls_ecp_point *)q)->MBEDTLS_PRIVATE(X), 0) == 0);
         TEST_ASSERT(crypto_ec_point_is_on_curve(e, q));
@@ -531,7 +531,7 @@ TEST_CASE("Test crypto lib ECC apis", "[wpa_crypto]")
         TEST_ASSERT(crypto_ec_point_add(e, q, r, r) == 0);
         TEST_ASSERT(crypto_ec_point_is_at_infinity(e, r));
 
-        mbedtls_mpi_free( &num );
+        esp_mbedtls_mpi_free( &num );
         crypto_ec_point_deinit(p, 1);
         crypto_ec_point_deinit(q, 1);
         crypto_ec_point_deinit(r, 1);
diff --git a/components/wpa_supplicant/test/test_dpp.c b/components/wpa_supplicant/test/test_dpp.c
index 6070842dc02be4bce167783c020ef1b4566fa20f..cff7753010f8eb462c5403cbd4a4c83b9f287ee8 100644
--- a/components/wpa_supplicant/test/test_dpp.c
+++ b/components/wpa_supplicant/test/test_dpp.c
@@ -65,7 +65,7 @@ TEST_CASE("Test vectors DPP responder p256", "[wpa_dpp]")
 		const char *uri;
 
 		char private_bootstrap_key[] = "54ce181a98525f217216f59b245f60e9df30ac7f6b26c939418cfc3c42d1afa0";
-		char bootstrap_info[] = "DPP:K:MDkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDIgACCcWFqRtN+f0loEUgGIXDnMXPrjl92u2pV97Ff6DjUD8=;;";
+		char bootstrap_info[] = "DPP:esp_K:MDkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDIgACCcWFqRtN+f0loEUgGIXDnMXPrjl92u2pV97Ff6DjUD8=;;";
 
 		sprintf(key, "%s%s%s", prefix, private_bootstrap_key, postfix);
 
